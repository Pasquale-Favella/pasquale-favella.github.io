"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8328],{38328:function(e,t,r){r.r(t),r.d(t,{InferenceSession:function(){return x},TRACE:function(){return D},TRACE_FUNC_BEGIN:function(){return C},TRACE_FUNC_END:function(){return L},Tensor:function(){return I},env:function(){return l},registerBackend:function(){return a}});let o=new Map,i=[],a=(e,t,r)=>{if(t&&"function"==typeof t.init&&"function"==typeof t.createInferenceSessionHandler){let a=o.get(e);if(void 0===a)o.set(e,{backend:t,priority:r});else if(a.priority>r)return;else if(a.priority===r&&a.backend!==t)throw Error(`cannot register backend "${e}" using priority ${r}`);if(r>=0){let t=i.indexOf(e);-1!==t&&i.splice(t,1);for(let t=0;t<i.length;t++)if(o.get(i[t]).priority<=r){i.splice(t,0,e);return}i.push(e)}return}throw TypeError("not a valid backend")},n=async e=>{let t=o.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return r||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},s=async e=>{let t;let r=e.executionProviders||[],o=r.map(e=>"string"==typeof e?e:e.name),a=0===o.length?i:o,s=[],f=new Set;for(let e of a){let r=await n(e);"string"==typeof r?s.push({name:e,err:r}):(t||(t=r),t===r&&f.add(e))}if(!t)throw Error(`no available backend found. ERR: ${s.map(e=>`[${e.name}] ${e.err}`).join(", ")}`);for(let{name:e,err:t}of s)o.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let d=r.filter(e=>f.has("string"==typeof e?e:e.name));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?d:Reflect.get(e,t)})]},f="warning",d={wasm:{},webgl:{},webgpu:{},versions:{common:"1.21.0"},set logLevel(value){if(void 0===value)return;if("string"!=typeof value||-1===["verbose","info","warning","error","fatal"].indexOf(value))throw Error(`Unsupported logging level: ${value}`);f=value},get logLevel(){return f}};Object.defineProperty(d,"logLevel",{enumerable:!0});let l=d,u=(e,t)=>{let r="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let o=r.getContext("2d");if(null!=o){let i,a,n,s;t?.tensorLayout!==void 0&&"NHWC"===t.tensorLayout?(i=e.dims[2],a=e.dims[3]):(i=e.dims[3],a=e.dims[2]);let f=t?.format!==void 0?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?n=[255,255,255,255]:"number"==typeof d.mean?n=[d.mean,d.mean,d.mean,d.mean]:(n=[d.mean[0],d.mean[1],d.mean[2],0],void 0!==d.mean[3]&&(n[3]=d.mean[3])),void 0===d||void 0===d.bias?s=[0,0,0,0]:"number"==typeof d.bias?s=[d.bias,d.bias,d.bias,d.bias]:(s=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(s[3]=d.bias[3]));let l=a*i,u=0,h=l,p=2*l,c=-1;"RGBA"===f?(u=0,h=l,p=2*l,c=3*l):"RGB"===f?(u=0,h=l,p=2*l):"RBG"===f&&(u=0,p=l,h=2*l);for(let t=0;t<a;t++)for(let r=0;r<i;r++){let i=(e.data[u++]-s[0])*n[0],a=(e.data[h++]-s[1])*n[1],f=(e.data[p++]-s[2])*n[2],d=-1===c?255:(e.data[c++]-s[3])*n[3];o.fillStyle="rgba("+i+","+a+","+f+","+d+")",o.fillRect(r,t,1,1)}if("toDataURL"in r)return r.toDataURL();throw Error("toDataURL is not supported")}throw Error("Can not access image data")},h=(e,t)=>{let r;let o="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null!=o){let i,a,n,s,f;t?.tensorLayout!==void 0&&"NHWC"===t.tensorLayout?(i=e.dims[2],a=e.dims[1],n=e.dims[3]):(i=e.dims[3],a=e.dims[2],n=e.dims[1]);let d=void 0!==t&&void 0!==t.format?t.format:"RGB",l=t?.norm;void 0===l||void 0===l.mean?s=[255,255,255,255]:"number"==typeof l.mean?s=[l.mean,l.mean,l.mean,l.mean]:(s=[l.mean[0],l.mean[1],l.mean[2],255],void 0!==l.mean[3]&&(s[3]=l.mean[3])),void 0===l||void 0===l.bias?f=[0,0,0,0]:"number"==typeof l.bias?f=[l.bias,l.bias,l.bias,l.bias]:(f=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(f[3]=l.bias[3]));let u=a*i;if(void 0!==t&&(void 0!==t.format&&4===n&&"RGBA"!==t.format||3===n&&"RGB"!==t.format&&"BGR"!==t.format))throw Error("Tensor format doesn't match input tensor dims");let h=0,p=1,c=2,m=3,y=0,g=u,w=2*u,b=-1;"RGBA"===d?(y=0,g=u,w=2*u,b=3*u):"RGB"===d?(y=0,g=u,w=2*u):"RBG"===d&&(y=0,w=u,g=2*u),r=o.createImageData(i,a);for(let t=0;t<a*i;h+=4,p+=4,c+=4,m+=4,t++)r.data[h]=(e.data[y++]-f[0])*s[0],r.data[p]=(e.data[g++]-f[1])*s[1],r.data[c]=(e.data[w++]-f[2])*s[2],r.data[m]=-1===b?255:(e.data[b++]-f[3])*s[3]}else throw Error("Can not access image data");return r},p=(e,t)=>{let r,o;if(void 0===e)throw Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw Error("NHWC Tensor layout is not supported yet");let{height:i,width:a}=t,n=t.norm??{mean:255,bias:0};r="number"==typeof n.mean?[n.mean,n.mean,n.mean,n.mean]:[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],o="number"==typeof n.bias?[n.bias,n.bias,n.bias,n.bias]:[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let s=void 0!==t.format?t.format:"RGBA",f=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",d=i*a,l=new Float32Array("RGBA"===f?4*d:3*d),u=4,h=0,p=1,c=2,m=3,y=0,g=d,w=2*d,b=-1;"RGB"===s&&(u=3,h=0,p=1,c=2,m=-1),"RGBA"===f?b=3*d:"RBG"===f?(y=0,w=d,g=2*d):"BGR"===f&&(w=0,g=d,y=2*d);for(let t=0;t<d;t++,h+=u,c+=u,p+=u,m+=u)l[y++]=(e[h]+o[0])/r[0],l[g++]=(e[p]+o[1])/r[1],l[w++]=(e[c]+o[2])/r[2],-1!==b&&-1!==m&&(l[b++]=(e[m]+o[3])/r[3]);return"RGBA"===f?new U("float32",l,[1,4,i,a]):new U("float32",l,[1,3,i,a])},c=async(e,t)=>{let r;let o="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,i="undefined"!=typeof ImageData&&e instanceof ImageData,a="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,n="string"==typeof e,s=t??{},f=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw Error("Canvas is not supported")},d=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement?e.getContext("2d"):e instanceof OffscreenCanvas?e.getContext("2d"):null;if(o){let o=f();o.width=e.width,o.height=e.height;let i=d(o);if(null!=i){let o=e.height,a=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(o=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=o,s.width=a}else s.tensorFormat="RGBA",s.height=o,s.width=a;i.drawImage(e,0,0),r=i.getImageData(0,0,a,o).data}else throw Error("Can not access image data")}else if(i){let o,i;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(o=t.resizedHeight,i=t.resizedWidth):(o=e.height,i=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=o,s.width=i,void 0!==t){let t=f();t.width=i,t.height=o;let a=d(t);if(null!=a)a.putImageData(e,0,0),r=a.getImageData(0,0,i,o).data;else throw Error("Can not access image data")}else r=e.data}else if(a){if(void 0===t)throw Error("Please provide image config with format for Imagebitmap");let o=f();o.width=e.width,o.height=e.height;let i=d(o);if(null!=i){let t=e.height,o=e.width;return i.drawImage(e,0,0,o,t),r=i.getImageData(0,0,o,t).data,s.height=t,s.width=o,p(r,s)}throw Error("Can not access image data")}else if(n)return new Promise((t,r)=>{let o=f(),i=d(o);if(!e||!i)return r();let a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{o.width=a.width,o.height=a.height,i.drawImage(a,0,0,o.width,o.height);let e=i.getImageData(0,0,o.width,o.height);s.height=o.height,s.width=o.width,t(p(e.data,s))}});else throw Error("Input data provided is not supported - aborted tensor creation");if(void 0!==r)return p(r,s);throw Error("Input data provided is not supported - aborted tensor creation")},m=(e,t)=>{let{width:r,height:o,download:i,dispose:a}=t;return new U({location:"texture",type:"float32",texture:e,dims:[1,o,r,4],download:i,dispose:a})},y=(e,t)=>{let{dataType:r,dims:o,download:i,dispose:a}=t;return new U({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:o,download:i,dispose:a})},g=(e,t)=>{let{dataType:r,dims:o,download:i,dispose:a}=t;return new U({location:"ml-tensor",type:r??"float32",mlTensor:e,dims:o,download:i,dispose:a})},w=(e,t,r)=>new U({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]}),b=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),v=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),E=!1,A=()=>{if(!E){E=!0;let e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,r=globalThis.Float16Array,o=void 0!==r&&r.from;e&&(b.set("int64",BigInt64Array),v.set(BigInt64Array,"int64")),t&&(b.set("uint64",BigUint64Array),v.set(BigUint64Array,"uint64")),o?(b.set("float16",r),v.set(r,"float16")):b.set("float16",Uint16Array)}},T=e=>{let t=1;for(let r=0;r<e.length;r++){let o=e[r];if("number"!=typeof o||!Number.isSafeInteger(o))throw TypeError(`dims[${r}] must be an integer, got: ${o}`);if(o<0)throw RangeError(`dims[${r}] must be a non-negative integer, got: ${o}`);t*=o}return t},B=(e,t)=>{switch(e.location){case"cpu":return new U(e.type,e.data,t);case"cpu-pinned":return new U({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new U({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new U({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new U({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw Error(`tensorReshape: tensor location ${e.location} is not supported`)}};class U{constructor(e,t,r){let o,i;if(A(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,o=e.type,i=e.dims,e.location){case"cpu-pinned":{let t=b.get(o);if(!t)throw TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==o)throw TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==o&&"float16"!==o&&"int32"!==o&&"int64"!==o&&"uint32"!==o&&"uint8"!==o&&"bool"!==o&&"uint4"!==o&&"int4"!==o)throw TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==o&&"float16"!==o&&"int32"!==o&&"int64"!==o&&"uint32"!==o&&"uint64"!==o&&"int8"!==o&&"uint8"!==o&&"bool"!==o&&"uint4"!==o&&"int4"!==o)throw TypeError(`unsupported type "${o}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,n;if("string"==typeof e){if(o=e,n=r,"string"===e){if(!Array.isArray(t))throw TypeError("A string tensor's data must be a string array.");a=t}else{let r=b.get(e);if(void 0===r)throw TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&r===Uint16Array||"uint4"===e||"int4"===e)throw TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${r.name} as data.`);a="uint64"===e||"int64"===e?r.from(t,BigInt):r.from(t)}else if(t instanceof r)a=t;else if(t instanceof Uint8ClampedArray){if("uint8"===e)a=Uint8Array.from(t);else throw TypeError("A Uint8ClampedArray tensor's data must be type of uint8")}else if("float16"===e&&t instanceof Uint16Array&&r!==Uint16Array)a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw TypeError(`A ${o} tensor's data must be type of ${r}`)}}else if(n=t,Array.isArray(e)){if(0===e.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)o="string",a=e;else if("boolean"===t)o="bool",a=Uint8Array.from(e);else throw TypeError(`Invalid element type of data array: ${t}.`)}else if(e instanceof Uint8ClampedArray)o="uint8",a=Uint8Array.from(e);else{let t=v.get(e.constructor);if(void 0===t)throw TypeError(`Unsupported type for tensor data: ${e.constructor}.`);o=t,a=e}if(void 0===n)n=[a.length];else if(!Array.isArray(n))throw TypeError("A tensor's dims must be a number array");i=n,this.cpuData=a,this.dataLocation="cpu"}let a=T(i);if(this.cpuData&&a!==this.cpuData.length){if(("uint4"===o||"int4"===o)&&Math.ceil(a/2)===this.cpuData.length);else throw Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`)}this.type=o,this.dims=i,this.size=a}static async fromImage(e,t){return c(e,t)}static fromTexture(e,t){return m(e,t)}static fromGpuBuffer(e,t){return y(e,t)}static fromMLTensor(e,t){return g(e,t)}static fromPinnedBuffer(e,t,r){return w(e,t,r)}toDataURL(e){return u(this,e)}toImageData(e){return h(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw Error("Cannot reshape a tensor that owns GPU resource.");return B(this,e)}}let I=U,D=(e,t)=>{(void 0===d.trace?!d.wasm.trace:!d.trace)||console.timeStamp(`${e}::ORT::${t}`)},R=(e,t)=>{let r=Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let i=0;i<r.length;i++){if(o&&!r[i].includes("TRACE_FUNC")){let o=`FUNC_${e}::${r[i].trim().split(" ")[1]}`;t&&(o+=`::${t}`),D("CPU",o);return}r[i].includes("TRACE_FUNC")&&(o=!0)}},C=e=>{(void 0===d.trace?!d.wasm.trace:!d.trace)||R("BEGIN",e)},L=e=>{(void 0===d.trace?!d.wasm.trace:!d.trace)||R("END",e)};class ${constructor(e){this.handler=e}async run(e,t,r){C();let o={},i={};if("object"!=typeof e||null===e||e instanceof I||Array.isArray(e))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof I)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw TypeError("'fetches' cannot be an empty array.");for(let e of(a=!1,t)){if("string"!=typeof e)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw RangeError(`'fetches' contains invalid output name: ${e}.`);o[e]=null}if("object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else{let e=!1,n=Object.getOwnPropertyNames(t);for(let r of this.outputNames)if(-1!==n.indexOf(r)){let i=t[r];(null===i||i instanceof I)&&(e=!0,a=!1,o[r]=i)}if(e){if("object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else i=t}}else if(void 0!==t)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(void 0===e[t])throw Error(`input '${t}' is missing in 'feeds'.`);if(a)for(let e of this.outputNames)o[e]=null;let n=await this.handler.run(e,o,i),s={};for(let e in n)if(Object.hasOwnProperty.call(n,e)){let t=n[e];t instanceof I?s[e]=t:s[e]=new I(t.type,t.data,t.dims)}return L(),s}async release(){return this.handler.dispose()}static async create(e,t,r,o){let i;C();let a={};if("string"==typeof e){if(i=e,"object"==typeof t&&null!==t)a=t;else if(void 0!==t)throw TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,"object"==typeof t&&null!==t)a=t;else if(void 0!==t)throw TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer){let n=0,s=e.byteLength;if("object"==typeof t&&null!==t)a=t;else if("number"==typeof t){if(!Number.isSafeInteger(n=t))throw RangeError("'byteOffset' must be an integer.");if(n<0||n>=e.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(s=e.byteLength-n,"number"==typeof r){if(!Number.isSafeInteger(s=r))throw RangeError("'byteLength' must be an integer.");if(s<=0||n+s>e.byteLength)throw RangeError(`'byteLength' is out of range (0, ${e.byteLength-n}].`);if("object"==typeof o&&null!==o)a=o;else if(void 0!==o)throw TypeError("'options' must be an object.")}else if(void 0!==r)throw TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw TypeError("'options' must be an object.");i=new Uint8Array(e,n,s)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[n,f]=await s(a),d=await n.createInferenceSessionHandler(i,f);return L(),new $(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}let x=$}}]);