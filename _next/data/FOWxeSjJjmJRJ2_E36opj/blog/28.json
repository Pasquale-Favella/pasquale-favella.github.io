{"pageProps":{"content":"The Compound Pattern in React represents a powerful design approach that enables developers to create flexible, reusable components that work together seamlessly. This pattern addresses common challenges like prop drilling while promoting declarative code that's both readable and maintainable. This comprehensive guide explores the compound pattern through practical TypeScript examples, performance considerations, and advanced implementations.\n\n## Understanding the Compound Pattern\n\nThe Compound Pattern involves creating a parent component that manages state and behavior, while child components consume and display this state through a shared context. Compound components are a pattern in React, where several components are used together such that they share an implicit state that allows them to communicate with each other in the background. This pattern is particularly effective when multiple components need to work together to accomplish a shared task.\n\n### What Makes It Special?\n\nCompound components can be said to be a pattern that encloses the state and the behavior of a group of components but still gives the rendering control of its variable parts back to the external user. This approach provides several key advantages:\n\n- **Declarative API**: Components express what they do, not how they do it\n- **Flexible Composition**: Users can arrange child components in any order\n- **Implicit State Sharing**: Components communicate without explicit prop passing\n- **Enhanced Reusability**: Each component can be used independently when needed\n- **Type Safety**: TypeScript provides excellent support for this pattern\n\n## The Prop Drilling Problem\n\nBefore diving into the compound pattern, let's examine the traditional prop drilling approach and its limitations.\n\n### Traditional Prop Drilling Example\n\nConsider a simple menu component built with traditional prop drilling:\n\n```tsx\n// Traditional approach with prop drilling\ninterface MenuItem {\n  id: string;\n  label: string;\n}\n\ninterface MenuProps {\n  isOpen: boolean;\n  onToggle: () => void;\n  items: MenuItem[];\n  activeItem: string | null;\n  onItemClick: (id: string) => void;\n}\n\nfunction Menu({ isOpen, onToggle, items, activeItem, onItemClick }: MenuProps) {\n  return (\n    <div className=\"menu\">\n      <MenuButton isOpen={isOpen} onToggle={onToggle} />\n      <MenuList \n        isOpen={isOpen} \n        items={items} \n        activeItem={activeItem} \n        onItemClick={onItemClick} \n      />\n    </div>\n  );\n}\n\ninterface MenuButtonProps {\n  isOpen: boolean;\n  onToggle: () => void;\n}\n\nfunction MenuButton({ isOpen, onToggle }: MenuButtonProps) {\n  return (\n    <button onClick={onToggle}>\n      {isOpen ? 'Close' : 'Open'} Menu\n    </button>\n  );\n}\n\ninterface MenuListProps {\n  isOpen: boolean;\n  items: MenuItem[];\n  activeItem: string | null;\n  onItemClick: (id: string) => void;\n}\n\nfunction MenuList({ isOpen, items, activeItem, onItemClick }: MenuListProps) {\n  if (!isOpen) return null;\n  \n  return (\n    <ul>\n      {items.map(item => (\n        <MenuItemComponent\n          key={item.id}\n          item={item}\n          isActive={item.id === activeItem}\n          onItemClick={onItemClick}\n        />\n      ))}\n    </ul>\n  );\n}\n\ninterface MenuItemComponentProps {\n  item: MenuItem;\n  isActive: boolean;\n  onItemClick: (id: string) => void;\n}\n\nfunction MenuItemComponent({ item, isActive, onItemClick }: MenuItemComponentProps) {\n  return (\n    <li \n      className={isActive ? 'active' : ''}\n      onClick={() => onItemClick(item.id)}\n    >\n      {item.label}\n    </li>\n  );\n}\n\n// Usage\nfunction App() {\n  const [isOpen, setIsOpen] = useState(false);\n  const [activeItem, setActiveItem] = useState<string | null>(null);\n  const items: MenuItem[] = [\n    { id: '1', label: 'Home' },\n    { id: '2', label: 'About' },\n    { id: '3', label: 'Contact' }\n  ];\n\n  return (\n    <Menu\n      isOpen={isOpen}\n      onToggle={() => setIsOpen(!isOpen)}\n      items={items}\n      activeItem={activeItem}\n      onItemClick={setActiveItem}\n    />\n  );\n}\n```\n\n### Problems with This Approach\n\nThe traditional approach presents several challenges:\n\n- **Tight Coupling**: Components are tightly bound to their parent's prop structure\n- **Verbose Props**: Every intermediate component must accept and pass props\n- **Limited Flexibility**: Changing the component structure requires updating multiple prop interfaces\n- **Poor Reusability**: Components become difficult to reuse in different contexts\n- **Complex Type Definitions**: Managing types across multiple levels becomes cumbersome\n\n## Compound Pattern Solution\n\nThe compound pattern elegantly solves these problems by using React Context to share state implicitly among related components.\n\n### Basic Compound Pattern Implementation\n\n```tsx\nimport React, { createContext, useContext, useState, ReactNode } from 'react';\n\n// Define the context type\ninterface MenuContextType {\n  isOpen: boolean;\n  setIsOpen: (isOpen: boolean) => void;\n  activeItem: string | null;\n  setActiveItem: (id: string | null) => void;\n  toggle: () => void;\n  selectItem: (id: string) => void;\n}\n\n// Create context for the compound component\nconst MenuContext = createContext<MenuContextType | undefined>(undefined);\n\n// Custom hook to access menu context\nfunction useMenuContext(): MenuContextType {\n  const context = useContext(MenuContext);\n  if (!context) {\n    throw new Error('Menu compound components must be used within Menu');\n  }\n  return context;\n}\n\n// Main Menu component interface\ninterface MenuProps {\n  children: ReactNode;\n}\n\n// Main Menu component that provides context\nfunction Menu({ children }: MenuProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [activeItem, setActiveItem] = useState<string | null>(null);\n\n  const contextValue: MenuContextType = {\n    isOpen,\n    setIsOpen,\n    activeItem,\n    setActiveItem,\n    toggle: () => setIsOpen(!isOpen),\n    selectItem: (id: string) => setActiveItem(id)\n  };\n\n  return (\n    <MenuContext.Provider value={contextValue}>\n      <div className=\"menu\">\n        {children}\n      </div>\n    </MenuContext.Provider>\n  );\n}\n\n// Compound components with proper typing\ninterface MenuButtonProps {\n  children?: ReactNode;\n}\n\nMenu.Button = function MenuButton({ children }: MenuButtonProps) {\n  const { isOpen, toggle } = useMenuContext();\n  \n  return (\n    <button onClick={toggle}>\n      {children || (isOpen ? 'Close Menu' : 'Open Menu')}\n    </button>\n  );\n};\n\ninterface MenuListProps {\n  children: ReactNode;\n}\n\nMenu.List = function MenuList({ children }: MenuListProps) {\n  const { isOpen } = useMenuContext();\n  \n  if (!isOpen) return null;\n  \n  return <ul className=\"menu-list\">{children}</ul>;\n};\n\ninterface MenuItemProps {\n  id: string;\n  children: ReactNode;\n}\n\nMenu.Item = function MenuItem({ id, children }: MenuItemProps) {\n  const { activeItem, selectItem } = useMenuContext();\n  const isActive = activeItem === id;\n  \n  return (\n    <li \n      className={`menu-item ${isActive ? 'active' : ''}`}\n      onClick={() => selectItem(id)}\n    >\n      {children}\n    </li>\n  );\n};\n\n// Clean, declarative usage with full type safety\nfunction App() {\n  return (\n    <Menu>\n      <Menu.Button>Toggle Navigation</Menu.Button>\n      <Menu.List>\n        <Menu.Item id=\"home\">Home</Menu.Item>\n        <Menu.Item id=\"about\">About</Menu.Item>\n        <Menu.Item id=\"services\">Services</Menu.Item>\n        <Menu.Item id=\"contact\">Contact</Menu.Item>\n      </Menu.List>\n    </Menu>\n  );\n}\n```\n\n### Key Improvements\n\nThe compound pattern version demonstrates several improvements:\n\n- **No Prop Drilling**: State is shared through context, eliminating prop passing\n- **Declarative Syntax**: The usage clearly expresses the component structure\n- **Flexible Composition**: Items can be arranged in any order or configuration\n- **Implicit Communication**: Components automatically stay in sync\n- **Type Safety**: Full TypeScript support with proper error handling\n\n## Advanced Compound Pattern Implementations\n\n### 1. Flexible Dialog Component\n\nHere's a more complex example showcasing the pattern's power with a dialog component:\n\n```tsx\nimport React, { \n  createContext, \n  useContext, \n  useState, \n  useEffect, \n  ReactNode, \n  MouseEvent,\n  KeyboardEvent\n} from 'react';\n\ninterface DialogContextType {\n  isOpen: boolean;\n  setIsOpen: (isOpen: boolean) => void;\n  loading: boolean;\n  setLoading: (loading: boolean) => void;\n  open: () => void;\n  close: () => void;\n  showLoading: () => void;\n  hideLoading: () => void;\n}\n\nconst DialogContext = createContext<DialogContextType | undefined>(undefined);\n\nfunction useDialogContext(): DialogContextType {\n  const context = useContext(DialogContext);\n  if (!context) {\n    throw new Error('Dialog compound components must be used within Dialog');\n  }\n  return context;\n}\n\ninterface DialogProps {\n  children: ReactNode;\n  onClose?: () => void;\n}\n\nfunction Dialog({ children, onClose }: DialogProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [loading, setLoading] = useState(false);\n\n  const contextValue: DialogContextType = {\n    isOpen,\n    setIsOpen,\n    loading,\n    setLoading,\n    open: () => setIsOpen(true),\n    close: () => {\n      setIsOpen(false);\n      onClose?.();\n    },\n    showLoading: () => setLoading(true),\n    hideLoading: () => setLoading(false)\n  };\n\n  // Handle escape key\n  useEffect(() => {\n    const handleEscape = (e: KeyboardEvent<Document>) => {\n      if (e.key === 'Escape' && isOpen) {\n        contextValue.close();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape as any);\n      document.body.style.overflow = 'hidden';\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleEscape as any);\n      document.body.style.overflow = 'unset';\n    };\n  }, [isOpen, contextValue]);\n\n  return (\n    <DialogContext.Provider value={contextValue}>\n      {children}\n    </DialogContext.Provider>\n  );\n}\n\ninterface DialogTriggerProps {\n  children: ReactNode;\n  asChild?: boolean;\n}\n\nDialog.Trigger = function DialogTrigger({ children, asChild = false }: DialogTriggerProps) {\n  const { open } = useDialogContext();\n  \n  if (asChild && React.isValidElement(children)) {\n    return React.cloneElement(children, { onClick: open });\n  }\n  \n  return <button onClick={open}>{children}</button>;\n};\n\ninterface DialogContentProps {\n  children: ReactNode;\n  className?: string;\n}\n\nDialog.Content = function DialogContent({ children, className = '' }: DialogContentProps) {\n  const { isOpen, close } = useDialogContext();\n  \n  if (!isOpen) return null;\n  \n  const handleOverlayClick = (e: MouseEvent<HTMLDivElement>) => {\n    if (e.target === e.currentTarget) {\n      close();\n    }\n  };\n  \n  return (\n    <div className={`dialog-overlay ${className}`} onClick={handleOverlayClick}>\n      <div className=\"dialog-content\">\n        {children}\n      </div>\n    </div>\n  );\n};\n\ninterface DialogHeaderProps {\n  children: ReactNode;\n}\n\nDialog.Header = function DialogHeader({ children }: DialogHeaderProps) {\n  return <div className=\"dialog-header\">{children}</div>;\n};\n\ninterface DialogBodyProps {\n  children: ReactNode;\n}\n\nDialog.Body = function DialogBody({ children }: DialogBodyProps) {\n  const { loading } = useDialogContext();\n  \n  return (\n    <div className=\"dialog-body\">\n      {loading && <div className=\"loading-spinner\">Loading...</div>}\n      {children}\n    </div>\n  );\n};\n\ninterface DialogFooterProps {\n  children: ReactNode;\n}\n\nDialog.Footer = function DialogFooter({ children }: DialogFooterProps) {\n  return <div className=\"dialog-footer\">{children}</div>;\n};\n\ninterface DialogCloseProps {\n  children?: ReactNode;\n}\n\nDialog.Close = function DialogClose({ children }: DialogCloseProps) {\n  const { close } = useDialogContext();\n  \n  return (\n    <button className=\"dialog-close\" onClick={close}>\n      {children || '×'}\n    </button>\n  );\n};\n\n// Usage example with full type safety\nfunction UserProfile() {\n  const handleSave = async (): Promise<void> => {\n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 2000));\n  };\n\n  return (\n    <Dialog onClose={() => console.log('Dialog closed')}>\n      <Dialog.Trigger>\n        <button className=\"primary-btn\">Edit Profile</button>\n      </Dialog.Trigger>\n      \n      <Dialog.Content>\n        <Dialog.Header>\n          <h2>Edit Profile</h2>\n          <Dialog.Close />\n        </Dialog.Header>\n        \n        <Dialog.Body>\n          <form>\n            <input type=\"text\" placeholder=\"Name\" />\n            <input type=\"email\" placeholder=\"Email\" />\n            <textarea placeholder=\"Bio\"></textarea>\n          </form>\n        </Dialog.Body>\n        \n        <Dialog.Footer>\n          <Dialog.Close>\n            <button className=\"secondary-btn\">Cancel</button>\n          </Dialog.Close>\n          <button className=\"primary-btn\" onClick={handleSave}>\n            Save Changes\n          </button>\n        </Dialog.Footer>\n      </Dialog.Content>\n    </Dialog>\n  );\n}\n```\n\n### 2. Advanced Data Table Component\n\nFor more complex scenarios, here's a data table implementation that showcases the pattern's scalability:\n\n```tsx\nimport React, { \n  createContext, \n  useContext, \n  useState, \n  useMemo, \n  ReactNode \n} from 'react';\n\n// Generic type for table data\ninterface TableData {\n  id: string | number;\n  [key: string]: any;\n}\n\ntype SortDirection = 'asc' | 'desc';\n\ninterface TableContextType<T extends TableData> {\n  data: T[];\n  originalData: T[];\n  sortColumn: keyof T | null;\n  sortDirection: SortDirection;\n  filters: Record<string, string>;\n  selectedRows: Set<string | number>;\n  sort: (column: keyof T) => void;\n  filter: (column: string, value: string) => void;\n  selectRow: (id: string | number) => void;\n  selectAllRows: () => void;\n  clearSelection: () => void;\n}\n\nconst TableContext = createContext<TableContextType<any> | undefined>(undefined);\n\nfunction useTableContext<T extends TableData>(): TableContextType<T> {\n  const context = useContext(TableContext);\n  if (!context) {\n    throw new Error('Table compound components must be used within Table');\n  }\n  return context;\n}\n\ninterface TableProps<T extends TableData> {\n  data: T[];\n  children: ReactNode;\n}\n\nfunction Table<T extends TableData>({ data, children }: TableProps<T>) {\n  const [sortColumn, setSortColumn] = useState<keyof T | null>(null);\n  const [sortDirection, setSortDirection] = useState<SortDirection>('asc');\n  const [filters, setFilters] = useState<Record<string, string>>({});\n  const [selectedRows, setSelectedRows] = useState<Set<string | number>>(new Set());\n\n  const processedData = useMemo(() => {\n    let result = [...data];\n\n    // Apply filters\n    Object.entries(filters).forEach(([column, value]) => {\n      if (value) {\n        result = result.filter(row => \n          String(row[column]).toLowerCase().includes(value.toLowerCase())\n        );\n      }\n    });\n\n    // Apply sorting\n    if (sortColumn) {\n      result.sort((a, b) => {\n        const aVal = a[sortColumn];\n        const bVal = b[sortColumn];\n        const modifier = sortDirection === 'asc' ? 1 : -1;\n        \n        if (aVal < bVal) return -1 * modifier;\n        if (aVal > bVal) return 1 * modifier;\n        return 0;\n      });\n    }\n\n    return result;\n  }, [data, filters, sortColumn, sortDirection]);\n\n  const contextValue: TableContextType<T> = {\n    data: processedData,\n    originalData: data,\n    sortColumn,\n    sortDirection,\n    filters,\n    selectedRows,\n    sort: (column: keyof T) => {\n      if (sortColumn === column) {\n        setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');\n      } else {\n        setSortColumn(column);\n        setSortDirection('asc');\n      }\n    },\n    filter: (column: string, value: string) => {\n      setFilters(prev => ({ ...prev, [column]: value }));\n    },\n    selectRow: (id: string | number) => {\n      setSelectedRows(prev => {\n        const newSet = new Set(prev);\n        if (newSet.has(id)) {\n          newSet.delete(id);\n        } else {\n          newSet.add(id);\n        }\n        return newSet;\n      });\n    },\n    selectAllRows: () => {\n      setSelectedRows(new Set(processedData.map(row => row.id)));\n    },\n    clearSelection: () => {\n      setSelectedRows(new Set());\n    }\n  };\n\n  return (\n    <TableContext.Provider value={contextValue}>\n      <div className=\"table-container\">\n        {children}\n      </div>\n    </TableContext.Provider>\n  );\n}\n\ninterface TableHeaderProps {\n  children: ReactNode;\n}\n\nTable.Header = function TableHeader({ children }: TableHeaderProps) {\n  return <thead className=\"table-header\">{children}</thead>;\n};\n\ninterface TableBodyProps {\n  children: ReactNode;\n}\n\nTable.Body = function TableBody({ children }: TableBodyProps) {\n  const { data } = useTableContext();\n  \n  return (\n    <tbody className=\"table-body\">\n      {data.map((row, index) => (\n        <TableRowProvider key={row.id} row={row} index={index}>\n          {children}\n        </TableRowProvider>\n      ))}\n    </tbody>\n  );\n};\n\ninterface TableRowProps {\n  children: ReactNode;\n}\n\nTable.Row = function TableRow({ children }: TableRowProps) {\n  const { row, index } = useTableRowContext();\n  const { selectedRows } = useTableContext();\n  \n  return (\n    <tr \n      className={`table-row ${selectedRows.has(row.id) ? 'selected' : ''}`}\n      data-index={index}\n    >\n      {children}\n    </tr>\n  );\n};\n\ninterface TableHeaderCellProps {\n  column?: string;\n  children: ReactNode;\n  sortable?: boolean;\n}\n\nTable.HeaderCell = function TableHeaderCell({ \n  column, \n  children, \n  sortable = false \n}: TableHeaderCellProps) {\n  const { sort, sortColumn, sortDirection } = useTableContext();\n  \n  const handleClick = () => {\n    if (sortable && column) {\n      sort(column);\n    }\n  };\n\n  return (\n    <th \n      className={`table-header-cell ${sortable ? 'sortable' : ''}`}\n      onClick={handleClick}\n    >\n      {children}\n      {sortable && sortColumn === column && (\n        <span className=\"sort-indicator\">\n          {sortDirection === 'asc' ? '↑' : '↓'}\n        </span>\n      )}\n    </th>\n  );\n};\n\ninterface TableCellProps {\n  column?: string;\n  children?: ReactNode;\n}\n\nTable.Cell = function TableCell({ column, children }: TableCellProps) {\n  const { row } = useTableRowContext();\n  \n  return (\n    <td className=\"table-cell\">\n      {children || (column ? row[column] : '')}\n    </td>\n  );\n};\n\nTable.SelectCell = function TableSelectCell() {\n  const { row } = useTableRowContext();\n  const { selectedRows, selectRow } = useTableContext();\n  \n  return (\n    <td className=\"table-select-cell\">\n      <input\n        type=\"checkbox\"\n        checked={selectedRows.has(row.id)}\n        onChange={() => selectRow(row.id)}\n      />\n    </td>\n  );\n};\n\ninterface TableFilterProps {\n  column: string;\n  placeholder?: string;\n}\n\nTable.Filter = function TableFilter({ column, placeholder }: TableFilterProps) {\n  const { filters, filter } = useTableContext();\n  \n  return (\n    <input\n      type=\"text\"\n      placeholder={placeholder}\n      value={filters[column] || ''}\n      onChange={(e) => filter(column, e.target.value)}\n      className=\"table-filter\"\n    />\n  );\n};\n\n// Row context for accessing current row data\ninterface TableRowContextType<T extends TableData = TableData> {\n  row: T;\n  index: number;\n}\n\nconst TableRowContext = createContext<TableRowContextType | undefined>(undefined);\n\ninterface TableRowProviderProps<T extends TableData> {\n  row: T;\n  index: number;\n  children: ReactNode;\n}\n\nfunction TableRowProvider<T extends TableData>({ \n  row, \n  index, \n  children \n}: TableRowProviderProps<T>) {\n  return (\n    <TableRowContext.Provider value={{ row, index }}>\n      {children}\n    </TableRowContext.Provider>\n  );\n}\n\nfunction useTableRowContext<T extends TableData = TableData>(): TableRowContextType<T> {\n  const context = useContext(TableRowContext);\n  if (!context) {\n    throw new Error('Table row components must be used within Table.Body');\n  }\n  return context as TableRowContextType<T>;\n}\n\n// Usage example with proper typing\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  role: 'Admin' | 'User';\n}\n\nfunction UsersTable() {\n  const users: User[] = [\n    { id: '1', name: 'John Doe', email: 'john@example.com', role: 'Admin' },\n    { id: '2', name: 'Jane Smith', email: 'jane@example.com', role: 'User' },\n    { id: '3', name: 'Bob Johnson', email: 'bob@example.com', role: 'User' }\n  ];\n\n  return (\n    <div>\n      <div className=\"table-controls\">\n        <Table.Filter column=\"name\" placeholder=\"Filter by name...\" />\n        <Table.Filter column=\"email\" placeholder=\"Filter by email...\" />\n      </div>\n      \n      <table>\n        <Table<User> data={users}>\n          <Table.Header>\n            <tr>\n              <Table.HeaderCell>\n                <input type=\"checkbox\" />\n              </Table.HeaderCell>\n              <Table.HeaderCell column=\"name\" sortable>\n                Name\n              </Table.HeaderCell>\n              <Table.HeaderCell column=\"email\" sortable>\n                Email\n              </Table.HeaderCell>\n              <Table.HeaderCell column=\"role\">\n                Role\n              </Table.HeaderCell>\n            </tr>\n          </Table.Header>\n          \n          <Table.Body>\n            <Table.Row>\n              <Table.SelectCell />\n              <Table.Cell column=\"name\" />\n              <Table.Cell column=\"email\" />\n              <Table.Cell column=\"role\">\n                <span className=\"role-badge\">\n                  {/* Custom rendering with full type safety */}\n                </span>\n              </Table.Cell>\n            </Table.Row>\n          </Table.Body>\n        </Table>\n      </div>\n    </div>\n  );\n}\n```\n\n## Performance Considerations\n\nWhile the compound pattern offers excellent developer experience, it's important to consider performance implications:\n\n### Context Performance Optimization\n\n```tsx\nimport React, { \n  createContext, \n  useContext, \n  useMemo, \n  useCallback, \n  useState,\n  ReactNode \n} from 'react';\n\ninterface MenuState {\n  isOpen: boolean;\n  activeItem: string | null;\n}\n\ninterface MenuActions {\n  toggle: () => void;\n  selectItem: (id: string) => void;\n}\n\nconst MenuStateContext = createContext<MenuState | undefined>(undefined);\nconst MenuActionsContext = createContext<MenuActions | undefined>(undefined);\n\ninterface OptimizedMenuProps {\n  children: ReactNode;\n}\n\nfunction OptimizedMenu({ children }: OptimizedMenuProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [activeItem, setActiveItem] = useState<string | null>(null);\n\n  // Separate state context (changes frequently)\n  const stateContextValue = useMemo((): MenuState => ({\n    isOpen,\n    activeItem\n  }), [isOpen, activeItem]);\n\n  // Separate actions context (stable)\n  const actionsContextValue = useMemo((): MenuActions => ({\n    toggle: () => setIsOpen(prev => !prev),\n    selectItem: (id: string) => setActiveItem(id)\n  }), []);\n\n  return (\n    <MenuStateContext.Provider value={stateContextValue}>\n      <MenuActionsContext.Provider value={actionsContextValue}>\n        <div className=\"menu\">{children}</div>\n      </MenuActionsContext.Provider>\n    </MenuStateContext.Provider>\n  );\n}\n\n// Separate hooks for better performance\nfunction useMenuState(): MenuState {\n  const context = useContext(MenuStateContext);\n  if (!context) {\n    throw new Error('useMenuState must be used within OptimizedMenu');\n  }\n  return context;\n}\n\nfunction useMenuActions(): MenuActions {\n  const context = useContext(MenuActionsContext);\n  if (!context) {\n    throw new Error('useMenuActions must be used within OptimizedMenu');\n  }\n  return context;\n}\n```\n\n### Best Practices for Performance\n\n1. **Split Contexts**: Separate frequently changing state from stable actions\n2. **Memoize Context Values**: Use `useMemo` to prevent unnecessary re-renders\n3. **Optimize Child Components**: Use `React.memo` for compound components when appropriate\n4. **Lazy Evaluation**: Only compute expensive values when needed\n5. **Proper TypeScript**: Use generics and proper typing for better performance and DX\n\n## When to Use the Compound Pattern\n\nThe compound pattern shines in specific scenarios:\n\n### Ideal Use Cases\n\n- **Related Component Groups**: When components naturally work together (tabs, accordion, dropdown)\n- **Complex State Management**: When multiple components need to share and synchronize state\n- **Flexible APIs**: When users need control over component arrangement and styling\n- **Design Systems**: When building reusable component libraries with TypeScript\n- **Library Development**: When creating components that need to be highly composable\n\n### When to Avoid\n\n- **Simple Components**: When prop drilling involves only one or two levels\n- **Performance-Critical Paths**: When context updates would cause expensive re-renders\n- **Unrelated Components**: When components don't naturally belong together\n- **Over-Engineering**: When simpler patterns would suffice\n\n## Comparison with Other Patterns\n\n### Compound Pattern vs. Render Props\n\n```tsx\n// Render Props approach\ninterface MenuRenderProps {\n  isOpen: boolean;\n  setIsOpen: (isOpen: boolean) => void;\n  toggle: () => void;\n}\n\ninterface MenuWithRenderProps {\n  children: (props: MenuRenderProps) => ReactNode;\n}\n\nfunction MenuWithRenderProps({ children }: MenuWithRenderProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  return children({ \n    isOpen, \n    setIsOpen, \n    toggle: () => setIsOpen(!isOpen) \n  });\n}\n\n// Usage - less declarative\n<MenuWithRenderProps>\n  {({ isOpen, toggle }) => (\n    <div>\n      <button onClick={toggle}>Toggle</button>\n      {isOpen && <ul>...</ul>}\n    </div>\n  )}\n</MenuWithRenderProps>\n\n// Compound Pattern is more declarative and readable\n<Menu>\n  <Menu.Button>Toggle</Menu.Button>\n  <Menu.List>...</Menu.List>\n</Menu>\n```\n\n### Compound Pattern vs. HOCs\n\nThe compound pattern offers better composition and avoids the wrapper hell often associated with Higher-Order Components while providing excellent TypeScript support and better inference.\n# **Extending the pattern: beyond composition**\n\nOnce you've grasped the power of the Compound Pattern, it's time to push beyond. Here are some advanced techniques that can transform your components from simple building blocks into true user interface ecosystems.\n\n## Auto-Detection of Child Components\n\nSometimes exposing a declarative API isn't enough, we also need to be smart about how our components behave based on their structure. Using `React.Children` and traversal functions, we can create components that automatically adapt to their content.\n\n```tsx\nimport React, { ReactNode, ReactElement, Children, isValidElement } from 'react';\n\ninterface TabsProps {\n  children: ReactNode;\n  defaultValue?: string;\n}\n\nfunction Tabs({ children, defaultValue }: TabsProps) {\n  const [activeTab, setActiveTab] = useState<string>(() => {\n    // Auto-detect first tab if no default provided\n    if (defaultValue) return defaultValue;\n    \n    const tabList = Children.toArray(children).find(\n      (child): child is ReactElement => \n        isValidElement(child) && child.type === Tabs.List\n    );\n    \n    if (tabList) {\n      const firstTrigger = Children.toArray(tabList.props.children).find(\n        (child): child is ReactElement => \n          isValidElement(child) && child.type === Tabs.Trigger\n      );\n      \n      return firstTrigger?.props.value || '';\n    }\n    \n    return '';\n  });\n\n  const contextValue = {\n    activeTab,\n    setActiveTab,\n    // Auto-detect available tabs\n    availableTabs: useMemo(() => {\n      const tabs: string[] = [];\n      \n      Children.forEach(children, (child) => {\n        if (isValidElement(child) && child.type === Tabs.Content) {\n          tabs.push(child.props.value);\n        }\n      });\n      \n      return tabs;\n    }, [children])\n  };\n\n  return (\n    <TabsContext.Provider value={contextValue}>\n      <div className=\"tabs\">{children}</div>\n    </TabsContext.Provider>\n  );\n}\n\nTabs.List = function TabsList({ children }: { children: ReactNode }) {\n  const { availableTabs } = useTabsContext();\n  \n  // Auto-filter only valid triggers\n  const validTriggers = Children.toArray(children).filter(\n    (child): child is ReactElement => \n      isValidElement(child) && \n      child.type === Tabs.Trigger &&\n      availableTabs.includes(child.props.value)\n  );\n\n  return (\n    <div className=\"tabs-list\" role=\"tablist\">\n      {validTriggers}\n    </div>\n  );\n};\n\nTabs.Trigger = function TabsTrigger({ \n  value,\n  children \n}: { \n  value: string; \n  children: ReactNode \n}) {\n  const { activeTab, setActiveTab } = useTabsContext();\n  \n  return (\n    <button\n      role=\"tab\"\n      aria-selected={activeTab === value}\n      className={`tabs-trigger ${activeTab === value ? 'active' : ''}`}\n      onClick={() => setActiveTab(value)}\n    >\n      {children}\n    </button>\n  );\n};\n\nTabs.Content = function TabsContent({ \n  value, \n  children \n}: { \n  value: string; \n  children: ReactNode \n}) {\n  const { activeTab } = useTabsContext();\n  \n  if (activeTab !== value) return null;\n  \n  return (\n    <div role=\"tabpanel\" className=\"tabs-content\">\n      {children}\n    </div>\n  );\n};\n\n// Usage with auto-detection\nfunction SmartTabs() {\n  return (\n    <Tabs defaultValue=\"overview\">\n      <Tabs.List>\n        <Tabs.Trigger value=\"overview\">Overview</Tabs.Trigger>\n        <Tabs.Trigger value=\"settings\">Settings</Tabs.Trigger>\n        <Tabs.Trigger value=\"invalid\">Invalid</Tabs.Trigger> {/* Automatically filtered */}\n      </Tabs.List>\n      \n      <Tabs.Content value=\"overview\">\n        <h2>Overview Content</h2>\n      </Tabs.Content>\n      \n      <Tabs.Content value=\"settings\">\n        <h2>Settings Content</h2>\n      </Tabs.Content>\n      \n      {/* The \"invalid\" trigger has no corresponding content */}\n    </Tabs>\n  );\n}\n```\n\n## Context Overrides at Intermediate Levels\n\nOne of the most powerful patterns is the ability to override compound component behavior at intermediate levels. This allows you to create nested components that can modify parent behavior without breaking the communication chain.\n\n```tsx\ninterface NestedMenuContextType extends MenuContextType {\n  level: number;\n  parentContext?: MenuContextType;\n}\n\nconst NestedMenuContext = createContext<NestedMenuContextType | undefined>(undefined);\n\ninterface SubmenuProps {\n  children: ReactNode;\n  trigger: ReactNode;\n  disabled?: boolean;\n}\n\nfunction Submenu({ children, trigger, disabled = false }: SubmenuProps) {\n  const parentContext = useMenuContext();\n  const [isOpen, setIsOpen] = useState(false);\n  \n  // Override specific behaviors while preserving parent context\n  const nestedContextValue: NestedMenuContextType = {\n    ...parentContext,\n    level: (parentContext as any).level + 1 || 1,\n    parentContext,\n    isOpen,\n    setIsOpen,\n    toggle: () => !disabled && setIsOpen(!isOpen),\n    // Preserve parent's active item logic\n    selectItem: (id: string) => {\n      parentContext.selectItem(id);\n      setIsOpen(false); // Close submenu when item is selected\n    }\n  };\n\n  return (\n    <NestedMenuContext.Provider value={nestedContextValue}>\n      <div className={`submenu level-${nestedContextValue.level}`}>\n        <div \n          className={`submenu-trigger ${disabled ? 'disabled' : ''}`}\n          onClick={nestedContextValue.toggle}\n        >\n          {trigger}\n        </div>\n        \n        {isOpen && (\n          <div className=\"submenu-content\">\n            {children}\n          </div>\n        )}\n      </div>\n    </NestedMenuContext.Provider>\n  );\n}\n\n// Hook that works with both normal and nested context\nfunction useMenuOrNestedContext(): MenuContextType | NestedMenuContextType {\n  const nestedContext = useContext(NestedMenuContext);\n  const menuContext = useMenuContext();\n  \n  return nestedContext || menuContext;\n}\n\n// Usage with nested overrides\nfunction AdvancedMenu() {\n  return (\n    <Menu>\n      <Menu.Button>Main Menu</Menu.Button>\n      <Menu.List>\n        <Menu.Item id=\"home\">Home</Menu.Item>\n        \n        <Submenu trigger={<span>Products ▶</span>}>\n          <Menu.Item id=\"product-1\">Product 1</Menu.Item>\n          <Menu.Item id=\"product-2\">Product 2</Menu.Item>\n          \n          <Submenu trigger={<span>Categories ▶</span>}>\n            <Menu.Item id=\"cat-1\">Category 1</Menu.Item>\n            <Menu.Item id=\"cat-2\">Category 2</Menu.Item>\n          </Submenu>\n        </Submenu>\n        \n        <Menu.Item id=\"about\">About</Menu.Item>\n      </Menu.List>\n    </Menu>\n  );\n}\n```\n\n## Dynamic Slots: The ShadCN/Radix Pattern\n\nThe true power of the compound pattern emerges when we implement dynamic slots, allowing components to adapt and reorganize based on content. This is the secret behind the flexibility of libraries like Radix UI and ShadCN.\n\n```tsx\ninterface SlotProps {\n  children?: ReactNode;\n  asChild?: boolean;\n}\n\n// Primitive Slot component inspired by Radix\nfunction Slot({ children, asChild = false, ...props }: SlotProps & any) {\n  if (asChild && React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...props,\n      ...children.props,\n      className: `${props.className || ''} ${children.props.className || ''}`.trim()\n    });\n  }\n  \n  return React.createElement('div', props, children);\n}\n\n// Advanced Dialog with dynamic slots\ninterface DialogWithSlotsProps {\n  children: ReactNode;\n  modal?: boolean;\n  onOpenChange?: (open: boolean) => void;\n}\n\nfunction DialogWithSlots({ children, modal = true, onOpenChange }: DialogWithSlotsProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  const handleOpenChange = (open: boolean) => {\n    setIsOpen(open);\n    onOpenChange?.(open);\n  };\n\n  // Detect and organize slots automatically\n  const slots = useMemo(() => {\n    const result: {\n      trigger?: ReactElement;\n      content?: ReactElement;\n      overlay?: ReactElement;\n      portal?: ReactElement;\n    } = {};\n    \n    Children.forEach(children, (child) => {\n      if (isValidElement(child)) {\n        const displayName = (child.type as any).displayName;\n        \n        switch (displayName) {\n          case 'DialogTrigger':\n            result.trigger = child;\n            break;\n          case 'DialogContent':\n            result.content = child;\n            break;\n          case 'DialogOverlay':\n            result.overlay = child;\n            break;\n          case 'DialogPortal':\n            result.portal = child;\n            break;\n        }\n      }\n    });\n    \n    return result;\n  }, [children]);\n\n  const contextValue = {\n    isOpen,\n    onOpenChange: handleOpenChange,\n    modal,\n    slots\n  };\n\n  return (\n    <DialogContext.Provider value={contextValue}>\n      {slots.trigger}\n      {isOpen && (\n        modal ? (\n          <DialogPortal>\n            {slots.overlay}\n            {slots.content}\n          </DialogPortal>\n        ) : (\n          <>\n            {slots.overlay}\n            {slots.content}\n          </>\n        )\n      )}\n    </DialogContext.Provider>\n  );\n}\n\n// Dynamic slot components\ninterface DialogTriggerProps {\n  children: ReactNode;\n  asChild?: boolean;\n}\n\nDialogWithSlots.Trigger = function DialogTrigger({ \n  children, \n  asChild = false \n}: DialogTriggerProps) {\n  const { onOpenChange } = useDialogContext();\n  \n  const handleClick = () => onOpenChange(true);\n  \n  return (\n    <Slot asChild={asChild} onClick={handleClick}>\n      {children}\n    </Slot>\n  );\n};\n\nDialogWithSlots.Trigger.displayName = 'DialogTrigger';\n\ninterface DialogContentProps {\n  children: ReactNode;\n  className?: string;\n  onPointerDownOutside?: (event: Event) => void;\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n}\n\nDialogWithSlots.Content = function DialogContent({\n  children,\n  className,\n  onPointerDownOutside,\n  onEscapeKeyDown\n}: DialogContentProps) {\n  const { isOpen, onOpenChange, modal } = useDialogContext();\n  \n  useEffect(() => {\n    const handleEscape = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        onEscapeKeyDown?.(e);\n        if (!e.defaultPrevented) {\n          onOpenChange(false);\n        }\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape);\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n    };\n  }, [isOpen, onOpenChange, onEscapeKeyDown]);\n\n  const handlePointerDownOutside = (e: Event) => {\n    onPointerDownOutside?.(e);\n    if (!e.defaultPrevented && modal) {\n      onOpenChange(false);\n    }\n  };\n\n  return (\n    <div\n      className={`dialog-content ${className || ''}`}\n      onPointerDown={(e) => {\n        if (e.target === e.currentTarget) {\n          handlePointerDownOutside(e.nativeEvent);\n        }\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n\nDialogWithSlots.Content.displayName = 'DialogContent';\n\n// Portal component for rendering outside DOM hierarchy\ninterface DialogPortalProps {\n  children: ReactNode;\n  container?: Element;\n}\n\nDialogWithSlots.Portal = function DialogPortal({ \n  children, \n  container \n}: DialogPortalProps) {\n  const [mounted, setMounted] = useState(false);\n  \n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  if (!mounted) return null;\n\n  return ReactDOM.createPortal(\n    children,\n    container || document.body\n  );\n};\n\nDialogWithSlots.Portal.displayName = 'DialogPortal';\n\n// Overlay component\ninterface DialogOverlayProps {\n  className?: string;\n  children?: ReactNode;\n}\n\nDialogWithSlots.Overlay = function DialogOverlay({ \n  className,\n  children \n}: DialogOverlayProps) {\n  return (\n    <div className={`dialog-overlay ${className || ''}`}>\n      {children}\n    </div>\n  );\n};\n\nDialogWithSlots.Overlay.displayName = 'DialogOverlay';\n\n// Advanced usage with complete flexibility\nfunction FlexibleDialog() {\n  return (\n    <DialogWithSlots modal onOpenChange={(open) => console.log('Dialog:', open)}>\n      <DialogWithSlots.Trigger asChild>\n        <button className=\"custom-trigger\">Open Advanced Dialog</button>\n      </DialogWithSlots.Trigger>\n      \n      <DialogWithSlots.Portal>\n        <DialogWithSlots.Overlay className=\"custom-overlay\" />\n        <DialogWithSlots.Content \n          className=\"custom-content\"\n          onEscapeKeyDown={(e) => {\n            console.log('Escape pressed');\n            // Could prevent default to keep dialog open\n          }}\n          onPointerDownOutside={(e) => {\n            console.log('Clicked outside');\n            // Could prevent default to keep dialog open\n          }}\n        >\n          <h2>Advanced Dialog</h2>\n          <p>This dialog uses dynamic slots and advanced composition patterns.</p>\n          \n          <DialogWithSlots.Trigger asChild>\n            <button>Close</button>\n          </DialogWithSlots.Trigger>\n        </DialogWithSlots.Content>\n      </DialogWithSlots.Portal>\n    </DialogWithSlots>\n  );\n}\n```\n\n\n## Conclusion and Recommendations\n\nThe Compound Pattern represents more than just a composition technique, it's a design philosophy that centers the developer experience and API flexibility. When fully mastered, it allows you to create components that are not only powerful but also delightful to use.\n\n**For Type Safety:**\n- Use generics to make your components reusable\n- Implement proper error boundaries and validation\n- Leverage TypeScript to create APIs that naturally guide correct usage\n\n**For Performance:**\n- Split contexts when state and actions update at different frequencies\n- Use `useMemo` and `useCallback` strategically\n- Consider the impact of re-renders on complex component trees\n\n**For Architecture:**\n- Apply the pattern to naturally related component groups\n- Maintain clear separation between state management and rendering logic\n- Design for composition, not configuration\n\n**For Extensibility:**\n- Implement dynamic slots for maximum flexibility\n- Allow context overrides at intermediate levels\n- Create custom hooks for complex behaviors\n\nThe compound pattern transforms how components feel to use. Not just functional, but intuitive. Not just flexible, but inevitable.\n\nYou'll know you've got it right when someone extends your component months later and the solution feels obvious, when complex UIs emerge from simple composition.\nThat's the mark of truly great component design.\n\n### Additional Resources\n\n- [React Compound Components Pattern](https://www.patterns.dev/react/compound-pattern/)\n- [Advanced React Patterns](https://github.com/kentcdodds/advanced-react-patterns)\n- [React Context API Documentation](https://react.dev/reference/react/createContext)\n- [Radix UI Primitives](https://www.radix-ui.com/primitives)\n- [ShadCN/UI Components](https://ui.shadcn.com/)\n\nHappy coding!","slug":"28","title":"Mastering the Compound Pattern in React: Building Declarative and Flexible Components with TypeScript","meta_description":"The Compound Pattern in React represents a powerful design approach that enables developers to create flexible, reusable components that work together seamlessly","tags":["React","Next JS"]},"__N_SSG":true}