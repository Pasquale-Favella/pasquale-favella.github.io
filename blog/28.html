<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:url" content="https://pasquale-favella.github.io/"/><meta property="og:image" content="https://pasquale-favella.github.io/og-image.png"/><meta property="og:locale" content="en_US"/><meta property="og:site_name" content="Pasquale Favella blogfolio"/><meta name="google-site-verification" content="BF08ecEW9P2w_w4mwWTU2LxdORMDiIO3XUeZLW7UC4o"/><link rel="icon" href="https://pasquale-favella.github.io/favicon.ico"/><title>Pasquale Favella | Mastering the Compound Pattern in React: Building Declarative and Flexible Components with TypeScript</title><meta name="robots" content="index,follow"/><meta name="description" content="The Compound Pattern in React represents a powerful design approach that enables developers to create flexible, reusable components that work together seamlessly"/><meta property="og:title" content="Pasquale Favella | Mastering the Compound Pattern in React: Building Declarative and Flexible Components with TypeScript"/><meta property="og:description" content="The Compound Pattern in React represents a powerful design approach that enables developers to create flexible, reusable components that work together seamlessly"/><meta property="og:type" content="article"/><meta property="article:tag" content="React"/><meta property="article:tag" content="Next JS"/><meta name="next-head-count" content="16"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/2c79f97859a6761f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2c79f97859a6761f.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-b6a6bb77651f8a1a.js" defer=""></script><script src="/_next/static/chunks/framework-b0ec748c7a4c483a.js" defer=""></script><script src="/_next/static/chunks/main-9a1845ad112863fa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c3a0093193621e18.js" defer=""></script><script src="/_next/static/chunks/5d416436-41b8439e5324d4fc.js" defer=""></script><script src="/_next/static/chunks/29107295-4cc022cea922dbb4.js" defer=""></script><script src="/_next/static/chunks/738-6862e37bdd712f9b.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-9cde532951e4ac35.js" defer=""></script><script src="/_next/static/dODZe4XLr2VvEciUuuaXU/_buildManifest.js" defer=""></script><script src="/_next/static/dODZe4XLr2VvEciUuuaXU/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,n='data-theme',s='setAttribute';var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';d[s](n,'dark')}else{d.style.colorScheme = 'light';d[s](n,'light')}}else if(e){d[s](n,e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><header class="fixed top-0 left-0 right-0 z-40 shadow-sm backdrop-blur-[10px] bg-base-100/80 saturate-100"><div class="mx-auto flex h-[60px] max-w-6xl items-center justify-between px-8"><div><a aria-label="Pasquale&#x27;s website" href="/"><div class="flex items-center justify-between text-xl font-semibold">~ P: /blog<div class="Typewriter" data-testid="typewriter-wrapper"></div></div></a></div><div class="flex items-center gap-2"><div class="tooltip tooltip-bottom before:text-xs before:content-[attr(data-tip)]" data-tip="commands"><button class="btn btn-ghost btn-circle btn-sm"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path></svg></button></div><div class="tooltip tooltip-bottom before:text-xs before:content-[attr(data-tip)]" data-tip="change theme"><label class="swap swap-rotate btn btn-ghost btn-circle btn-sm"><input id="theme-toggle" type="checkbox"/><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="swap-on" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"></path></svg><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="swap-off" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M10 6C10 10.4183 13.5817 14 18 14C19.4386 14 20.7885 13.6203 21.9549 12.9556C21.4738 18.0302 17.2005 22 12 22C6.47715 22 2 17.5228 2 12C2 6.79948 5.9698 2.52616 11.0444 2.04507C10.3797 3.21152 10 4.56142 10 6ZM4 12C4 16.4183 7.58172 20 12 20C14.9654 20 17.5757 18.3788 18.9571 15.9546C18.6407 15.9848 18.3214 16 18 16C12.4772 16 8 11.5228 8 6C8 5.67863 8.01524 5.35933 8.04536 5.04293C5.62119 6.42426 4 9.03458 4 12ZM18.1642 2.29104L19 2.5V3.5L18.1642 3.70896C17.4476 3.8881 16.8881 4.4476 16.709 5.16417L16.5 6H15.5L15.291 5.16417C15.1119 4.4476 14.5524 3.8881 13.8358 3.70896L13 3.5V2.5L13.8358 2.29104C14.5524 2.1119 15.1119 1.5524 15.291 0.835829L15.5 0H16.5L16.709 0.835829C16.8881 1.5524 17.4476 2.1119 18.1642 2.29104ZM23.1642 7.29104L24 7.5V8.5L23.1642 8.70896C22.4476 8.8881 21.8881 9.4476 21.709 10.1642L21.5 11H20.5L20.291 10.1642C20.1119 9.4476 19.5524 8.8881 18.8358 8.70896L18 8.5V7.5L18.8358 7.29104C19.5524 7.1119 20.1119 6.5524 20.291 5.83583L20.5 5H21.5L21.709 5.83583C21.8881 6.5524 22.4476 7.1119 23.1642 7.29104Z"></path></svg></label></div></div></div></header><main class="relative mx-auto min-h-layout max-w-6xl px-8 pt-20 mb-2"><a class="group fixed top-24 hidden items-center justify-center text-sm font-medium xl:inline-flex" href="/blog"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="h-4 w-4 transition duration-200 group-hover:translate-x-1" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" d="M0 0h24v24H0V0z"></path><path d="M15.41 16.59 10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"></path></svg><span>See all Posts</span></a><div class="prose md:prose-lg lg:prose-xl mx-auto  mb-3 lg:mb-5"><h1 class="text-4xl font-extrabold leading-tight md:text-5xl !mb-4">Mastering the Compound Pattern in React: Building Declarative and Flexible Components with TypeScript</h1><div class="flex gap-2"><a class="badge badge-lg border-base-content hover:border-accent-content hover:opacity-80 no-underline py-4" href="/blog?tag=React"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 20 20" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M9.243 3.03a1 1 0 01.727 1.213L9.53 6h2.94l.56-2.243a1 1 0 111.94.486L14.53 6H17a1 1 0 110 2h-2.97l-1 4H15a1 1 0 110 2h-2.47l-.56 2.242a1 1 0 11-1.94-.485L10.47 14H7.53l-.56 2.242a1 1 0 11-1.94-.485L5.47 14H3a1 1 0 110-2h2.97l1-4H5a1 1 0 110-2h2.47l.56-2.243a1 1 0 011.213-.727zM9.03 8l-1 4h2.938l1-4H9.031z" clip-rule="evenodd"></path></svg>React</a><a class="badge badge-lg border-base-content hover:border-accent-content hover:opacity-80 no-underline py-4" href="/blog?tag=Next+JS"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 20 20" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M9.243 3.03a1 1 0 01.727 1.213L9.53 6h2.94l.56-2.243a1 1 0 111.94.486L14.53 6H17a1 1 0 110 2h-2.97l-1 4H15a1 1 0 110 2h-2.47l-.56 2.242a1 1 0 11-1.94-.485L10.47 14H7.53l-.56 2.242a1 1 0 11-1.94-.485L5.47 14H3a1 1 0 110-2h2.97l1-4H5a1 1 0 110-2h2.47l.56-2.243a1 1 0 011.213-.727zM9.03 8l-1 4h2.938l1-4H9.031z" clip-rule="evenodd"></path></svg>Next JS</a></div></div><article class="prose md:prose-lg lg:prose-xl mx-auto"><p>The Compound Pattern in React represents a powerful design approach that enables developers to create flexible, reusable components that work together seamlessly. This pattern addresses common challenges like prop drilling while promoting declarative code that's both readable and maintainable. This comprehensive guide explores the compound pattern through practical TypeScript examples, performance considerations, and advanced implementations.</p>
<h2>Understanding the Compound Pattern</h2>
<p>The Compound Pattern involves creating a parent component that manages state and behavior, while child components consume and display this state through a shared context. Compound components are a pattern in React, where several components are used together such that they share an implicit state that allows them to communicate with each other in the background. This pattern is particularly effective when multiple components need to work together to accomplish a shared task.</p>
<h3>What Makes It Special?</h3>
<p>Compound components can be said to be a pattern that encloses the state and the behavior of a group of components but still gives the rendering control of its variable parts back to the external user. This approach provides several key advantages:</p>
<ul>
<li><strong>Declarative API</strong>: Components express what they do, not how they do it</li>
<li><strong>Flexible Composition</strong>: Users can arrange child components in any order</li>
<li><strong>Implicit State Sharing</strong>: Components communicate without explicit prop passing</li>
<li><strong>Enhanced Reusability</strong>: Each component can be used independently when needed</li>
<li><strong>Type Safety</strong>: TypeScript provides excellent support for this pattern</li>
</ul>
<h2>The Prop Drilling Problem</h2>
<p>Before diving into the compound pattern, let's examine the traditional prop drilling approach and its limitations.</p>
<h3>Traditional Prop Drilling Example</h3>
<p>Consider a simple menu component built with traditional prop drilling:</p>

<div style="position: relative">
	<pre><code class="hljs language-tsx"><span class="hljs-comment">// Traditional approach with prop drilling</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuItem</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">label</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuProps</span> {
  <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">onToggle</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">items</span>: <span class="hljs-title class_">MenuItem</span>[];
  <span class="hljs-attr">activeItem</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  <span class="hljs-attr">onItemClick</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Menu</span>(<span class="hljs-params">{ isOpen, onToggle, items, activeItem, onItemClick }: MenuProps</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">MenuButton</span> <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{isOpen}</span> <span class="hljs-attr">onToggle</span>=<span class="hljs-string">{onToggle}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">MenuList</span> 
        <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{isOpen}</span> 
        <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> 
        <span class="hljs-attr">activeItem</span>=<span class="hljs-string">{activeItem}</span> 
        <span class="hljs-attr">onItemClick</span>=<span class="hljs-string">{onItemClick}</span> 
      /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuButtonProps</span> {
  <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">onToggle</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MenuButton</span>(<span class="hljs-params">{ isOpen, onToggle }: MenuButtonProps</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onToggle}</span>&gt;</span>
      {isOpen ? &#x27;Close&#x27; : &#x27;Open&#x27;} Menu
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuListProps</span> {
  <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">items</span>: <span class="hljs-title class_">MenuItem</span>[];
  <span class="hljs-attr">activeItem</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  <span class="hljs-attr">onItemClick</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MenuList</span>(<span class="hljs-params">{ isOpen, items, activeItem, onItemClick }: MenuListProps</span>) {
  <span class="hljs-keyword">if</span> (!isOpen) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      {items.map(item =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">MenuItemComponent</span>
          <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>
          <span class="hljs-attr">item</span>=<span class="hljs-string">{item}</span>
          <span class="hljs-attr">isActive</span>=<span class="hljs-string">{item.id</span> === <span class="hljs-string">activeItem}</span>
          <span class="hljs-attr">onItemClick</span>=<span class="hljs-string">{onItemClick}</span>
        /&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuItemComponentProps</span> {
  <span class="hljs-attr">item</span>: <span class="hljs-title class_">MenuItem</span>;
  <span class="hljs-attr">isActive</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">onItemClick</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MenuItemComponent</span>(<span class="hljs-params">{ item, isActive, onItemClick }: MenuItemComponentProps</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
      <span class="hljs-attr">className</span>=<span class="hljs-string">{isActive</span> ? &#x27;<span class="hljs-attr">active</span>&#x27; <span class="hljs-attr">:</span> &#x27;&#x27;}
      <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> onItemClick(item.id)}
    &gt;
      {item.label}
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [activeItem, setActiveItem] = useState&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-attr">items</span>: <span class="hljs-title class_">MenuItem</span>[] = [
    { <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Home&#x27;</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;About&#x27;</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;Contact&#x27;</span> }
  ];

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Menu</span>
      <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{isOpen}</span>
      <span class="hljs-attr">onToggle</span>=<span class="hljs-string">{()</span> =&gt;</span> setIsOpen(!isOpen)}
      items={items}
      activeItem={activeItem}
      onItemClick={setActiveItem}
    /&gt;</span>
  );
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="// Traditional approach with prop drilling
interface MenuItem {
  id: string;
  label: string;
}

interface MenuProps {
  isOpen: boolean;
  onToggle: () => void;
  items: MenuItem[];
  activeItem: string | null;
  onItemClick: (id: string) => void;
}

function Menu({ isOpen, onToggle, items, activeItem, onItemClick }: MenuProps) {
  return (
    <div className=&quot;menu&quot;>
      <MenuButton isOpen={isOpen} onToggle={onToggle} />
      <MenuList 
        isOpen={isOpen} 
        items={items} 
        activeItem={activeItem} 
        onItemClick={onItemClick} 
      />
    </div>
  );
}

interface MenuButtonProps {
  isOpen: boolean;
  onToggle: () => void;
}

function MenuButton({ isOpen, onToggle }: MenuButtonProps) {
  return (
    <button onClick={onToggle}>
      {isOpen ? &apos;Close&apos; : &apos;Open&apos;} Menu
    </button>
  );
}

interface MenuListProps {
  isOpen: boolean;
  items: MenuItem[];
  activeItem: string | null;
  onItemClick: (id: string) => void;
}

function MenuList({ isOpen, items, activeItem, onItemClick }: MenuListProps) {
  if (!isOpen) return null;
  
  return (
    <ul>
      {items.map(item => (
        <MenuItemComponent
          key={item.id}
          item={item}
          isActive={item.id === activeItem}
          onItemClick={onItemClick}
        />
      ))}
    </ul>
  );
}

interface MenuItemComponentProps {
  item: MenuItem;
  isActive: boolean;
  onItemClick: (id: string) => void;
}

function MenuItemComponent({ item, isActive, onItemClick }: MenuItemComponentProps) {
  return (
    <li 
      className={isActive ? &apos;active&apos; : &apos;&apos;}
      onClick={() => onItemClick(item.id)}
    >
      {item.label}
    </li>
  );
}

// Usage
function App() {
  const [isOpen, setIsOpen] = useState(false);
  const [activeItem, setActiveItem] = useState<string | null>(null);
  const items: MenuItem[] = [
    { id: &apos;1&apos;, label: &apos;Home&apos; },
    { id: &apos;2&apos;, label: &apos;About&apos; },
    { id: &apos;3&apos;, label: &apos;Contact&apos; }
  ];

  return (
    <Menu
      isOpen={isOpen}
      onToggle={() => setIsOpen(!isOpen)}
      items={items}
      activeItem={activeItem}
      onItemClick={setActiveItem}
    />
  );
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h3>Problems with This Approach</h3>
<p>The traditional approach presents several challenges:</p>
<ul>
<li><strong>Tight Coupling</strong>: Components are tightly bound to their parent's prop structure</li>
<li><strong>Verbose Props</strong>: Every intermediate component must accept and pass props</li>
<li><strong>Limited Flexibility</strong>: Changing the component structure requires updating multiple prop interfaces</li>
<li><strong>Poor Reusability</strong>: Components become difficult to reuse in different contexts</li>
<li><strong>Complex Type Definitions</strong>: Managing types across multiple levels becomes cumbersome</li>
</ul>
<h2>Compound Pattern Solution</h2>
<p>The compound pattern elegantly solves these problems by using React Context to share state implicitly among related components.</p>
<h3>Basic Compound Pattern Implementation</h3>

<div style="position: relative">
	<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { createContext, useContext, useState, <span class="hljs-title class_">ReactNode</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-comment">// Define the context type</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuContextType</span> {
  <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">setIsOpen</span>: <span class="hljs-function">(<span class="hljs-params">isOpen: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">activeItem</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  <span class="hljs-attr">setActiveItem</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">toggle</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">selectItem</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-comment">// Create context for the compound component</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MenuContext</span> = createContext&lt;<span class="hljs-title class_">MenuContextType</span> | <span class="hljs-literal">undefined</span>&gt;(<span class="hljs-literal">undefined</span>);

<span class="hljs-comment">// Custom hook to access menu context</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useMenuContext</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MenuContextType</span> {
  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MenuContext</span>);
  <span class="hljs-keyword">if</span> (!context) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Menu compound components must be used within Menu&#x27;</span>);
  }
  <span class="hljs-keyword">return</span> context;
}

<span class="hljs-comment">// Main Menu component interface</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-comment">// Main Menu component that provides context</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Menu</span>(<span class="hljs-params">{ children }: MenuProps</span>) {
  <span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [activeItem, setActiveItem] = useState&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-attr">contextValue</span>: <span class="hljs-title class_">MenuContextType</span> = {
    isOpen,
    setIsOpen,
    activeItem,
    setActiveItem,
    <span class="hljs-attr">toggle</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setIsOpen</span>(!isOpen),
    <span class="hljs-attr">selectItem</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-title function_">setActiveItem</span>(id)
  };

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MenuContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{contextValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span>
        {children}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">MenuContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// Compound components with proper typing</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuButtonProps</span> {
  children?: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Menu</span>.<span class="hljs-property">Button</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">MenuButton</span>(<span class="hljs-params">{ children }: MenuButtonProps</span>) {
  <span class="hljs-keyword">const</span> { isOpen, toggle } = <span class="hljs-title function_">useMenuContext</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{toggle}</span>&gt;</span>
      {children || (isOpen ? &#x27;Close Menu&#x27; : &#x27;Open Menu&#x27;)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuListProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Menu</span>.<span class="hljs-property">List</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">MenuList</span>(<span class="hljs-params">{ children }: MenuListProps</span>) {
  <span class="hljs-keyword">const</span> { isOpen } = <span class="hljs-title function_">useMenuContext</span>();
  
  <span class="hljs-keyword">if</span> (!isOpen) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;menu-list&quot;</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>;
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuItemProps</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Menu</span>.<span class="hljs-property">Item</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">MenuItem</span>(<span class="hljs-params">{ id, children }: MenuItemProps</span>) {
  <span class="hljs-keyword">const</span> { activeItem, selectItem } = <span class="hljs-title function_">useMenuContext</span>();
  <span class="hljs-keyword">const</span> isActive = activeItem === id;
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
      <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">menu-item</span> ${<span class="hljs-attr">isActive</span> ? &#x27;<span class="hljs-attr">active</span>&#x27; <span class="hljs-attr">:</span> &#x27;&#x27;}`}
      <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> selectItem(id)}
    &gt;
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// Clean, declarative usage with full type safety</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Menu</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Button</span>&gt;</span>Toggle Navigation<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Menu.List</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;services&quot;</span>&gt;</span>Services<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;contact&quot;</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Menu.List</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Menu</span>&gt;</span></span>
  );
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="import React, { createContext, useContext, useState, ReactNode } from &apos;react&apos;;

// Define the context type
interface MenuContextType {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  activeItem: string | null;
  setActiveItem: (id: string | null) => void;
  toggle: () => void;
  selectItem: (id: string) => void;
}

// Create context for the compound component
const MenuContext = createContext<MenuContextType | undefined>(undefined);

// Custom hook to access menu context
function useMenuContext(): MenuContextType {
  const context = useContext(MenuContext);
  if (!context) {
    throw new Error(&apos;Menu compound components must be used within Menu&apos;);
  }
  return context;
}

// Main Menu component interface
interface MenuProps {
  children: ReactNode;
}

// Main Menu component that provides context
function Menu({ children }: MenuProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [activeItem, setActiveItem] = useState<string | null>(null);

  const contextValue: MenuContextType = {
    isOpen,
    setIsOpen,
    activeItem,
    setActiveItem,
    toggle: () => setIsOpen(!isOpen),
    selectItem: (id: string) => setActiveItem(id)
  };

  return (
    <MenuContext.Provider value={contextValue}>
      <div className=&quot;menu&quot;>
        {children}
      </div>
    </MenuContext.Provider>
  );
}

// Compound components with proper typing
interface MenuButtonProps {
  children?: ReactNode;
}

Menu.Button = function MenuButton({ children }: MenuButtonProps) {
  const { isOpen, toggle } = useMenuContext();
  
  return (
    <button onClick={toggle}>
      {children || (isOpen ? &apos;Close Menu&apos; : &apos;Open Menu&apos;)}
    </button>
  );
};

interface MenuListProps {
  children: ReactNode;
}

Menu.List = function MenuList({ children }: MenuListProps) {
  const { isOpen } = useMenuContext();
  
  if (!isOpen) return null;
  
  return <ul className=&quot;menu-list&quot;>{children}</ul>;
};

interface MenuItemProps {
  id: string;
  children: ReactNode;
}

Menu.Item = function MenuItem({ id, children }: MenuItemProps) {
  const { activeItem, selectItem } = useMenuContext();
  const isActive = activeItem === id;
  
  return (
    <li 
      className={`menu-item ${isActive ? &apos;active&apos; : &apos;&apos;}`}
      onClick={() => selectItem(id)}
    >
      {children}
    </li>
  );
};

// Clean, declarative usage with full type safety
function App() {
  return (
    <Menu>
      <Menu.Button>Toggle Navigation</Menu.Button>
      <Menu.List>
        <Menu.Item id=&quot;home&quot;>Home</Menu.Item>
        <Menu.Item id=&quot;about&quot;>About</Menu.Item>
        <Menu.Item id=&quot;services&quot;>Services</Menu.Item>
        <Menu.Item id=&quot;contact&quot;>Contact</Menu.Item>
      </Menu.List>
    </Menu>
  );
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h3>Key Improvements</h3>
<p>The compound pattern version demonstrates several improvements:</p>
<ul>
<li><strong>No Prop Drilling</strong>: State is shared through context, eliminating prop passing</li>
<li><strong>Declarative Syntax</strong>: The usage clearly expresses the component structure</li>
<li><strong>Flexible Composition</strong>: Items can be arranged in any order or configuration</li>
<li><strong>Implicit Communication</strong>: Components automatically stay in sync</li>
<li><strong>Type Safety</strong>: Full TypeScript support with proper error handling</li>
</ul>
<h2>Advanced Compound Pattern Implementations</h2>
<h3>1. Flexible Dialog Component</h3>
<p>Here's a more complex example showcasing the pattern's power with a dialog component:</p>

<div style="position: relative">
	<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { 
  createContext, 
  useContext, 
  useState, 
  useEffect, 
  <span class="hljs-title class_">ReactNode</span>, 
  <span class="hljs-title class_">MouseEvent</span>,
  <span class="hljs-title class_">KeyboardEvent</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogContextType</span> {
  <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">setIsOpen</span>: <span class="hljs-function">(<span class="hljs-params">isOpen: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">loading</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">setLoading</span>: <span class="hljs-function">(<span class="hljs-params">loading: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">open</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">close</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">showLoading</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">hideLoading</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">DialogContext</span> = createContext&lt;<span class="hljs-title class_">DialogContextType</span> | <span class="hljs-literal">undefined</span>&gt;(<span class="hljs-literal">undefined</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useDialogContext</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">DialogContextType</span> {
  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">DialogContext</span>);
  <span class="hljs-keyword">if</span> (!context) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Dialog compound components must be used within Dialog&#x27;</span>);
  }
  <span class="hljs-keyword">return</span> context;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  onClose?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Dialog</span>(<span class="hljs-params">{ children, onClose }: DialogProps</span>) {
  <span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-attr">contextValue</span>: <span class="hljs-title class_">DialogContextType</span> = {
    isOpen,
    setIsOpen,
    loading,
    setLoading,
    <span class="hljs-attr">open</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-literal">true</span>),
    <span class="hljs-attr">close</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-literal">false</span>);
      onClose?.();
    },
    <span class="hljs-attr">showLoading</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>),
    <span class="hljs-attr">hideLoading</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)
  };

  <span class="hljs-comment">// Handle escape key</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleEscape</span> = (<span class="hljs-params">e: KeyboardEvent&lt;Document&gt;</span>) =&gt; {
      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;Escape&#x27;</span> &amp;&amp; isOpen) {
        contextValue.<span class="hljs-title function_">close</span>();
      }
    };

    <span class="hljs-keyword">if</span> (isOpen) {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, handleEscape <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>);
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">overflow</span> = <span class="hljs-string">&#x27;hidden&#x27;</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, handleEscape <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>);
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">overflow</span> = <span class="hljs-string">&#x27;unset&#x27;</span>;
    };
  }, [isOpen, contextValue]);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DialogContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{contextValue}</span>&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">DialogContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogTriggerProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  asChild?: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-title class_">Dialog</span>.<span class="hljs-property">Trigger</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogTrigger</span>(<span class="hljs-params">{ children, asChild = <span class="hljs-literal">false</span> }: DialogTriggerProps</span>) {
  <span class="hljs-keyword">const</span> { open } = <span class="hljs-title function_">useDialogContext</span>();
  
  <span class="hljs-keyword">if</span> (asChild &amp;&amp; <span class="hljs-title class_">React</span>.<span class="hljs-title function_">isValidElement</span>(children)) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">cloneElement</span>(children, { <span class="hljs-attr">onClick</span>: open });
  }
  
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{open}</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogContentProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  className?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-title class_">Dialog</span>.<span class="hljs-property">Content</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogContent</span>(<span class="hljs-params">{ children, className = <span class="hljs-string">&#x27;&#x27;</span> }: DialogContentProps</span>) {
  <span class="hljs-keyword">const</span> { isOpen, close } = <span class="hljs-title function_">useDialogContext</span>();
  
  <span class="hljs-keyword">if</span> (!isOpen) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleOverlayClick</span> = (<span class="hljs-params">e: MouseEvent&lt;HTMLDivElement&gt;</span>) =&gt; {
    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> === e.<span class="hljs-property">currentTarget</span>) {
      <span class="hljs-title function_">close</span>();
    }
  };
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">dialog-overlay</span> ${<span class="hljs-attr">className</span>}`} <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleOverlayClick}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;dialog-content&quot;</span>&gt;</span>
        {children}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogHeaderProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Dialog</span>.<span class="hljs-property">Header</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogHeader</span>(<span class="hljs-params">{ children }: DialogHeaderProps</span>) {
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;dialog-header&quot;</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogBodyProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Dialog</span>.<span class="hljs-property">Body</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogBody</span>(<span class="hljs-params">{ children }: DialogBodyProps</span>) {
  <span class="hljs-keyword">const</span> { loading } = <span class="hljs-title function_">useDialogContext</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;dialog-body&quot;</span>&gt;</span>
      {loading &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;loading-spinner&quot;</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogFooterProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Dialog</span>.<span class="hljs-property">Footer</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogFooter</span>(<span class="hljs-params">{ children }: DialogFooterProps</span>) {
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;dialog-footer&quot;</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogCloseProps</span> {
  children?: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Dialog</span>.<span class="hljs-property">Close</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogClose</span>(<span class="hljs-params">{ children }: DialogCloseProps</span>) {
  <span class="hljs-keyword">const</span> { close } = <span class="hljs-title function_">useDialogContext</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;dialog-close&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{close}</span>&gt;</span>
      {children || &#x27;Ã—&#x27;}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// Usage example with full type safety</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> handleSave = <span class="hljs-keyword">async</span> (): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; =&gt; {
    <span class="hljs-comment">// Simulate API call</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">2000</span>));
  };

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span> <span class="hljs-attr">onClose</span>=<span class="hljs-string">{()</span> =&gt;</span> console.log(&#x27;Dialog closed&#x27;)}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">Dialog.Trigger</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;primary-btn&quot;</span>&gt;</span>Edit Profile<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog.Trigger</span>&gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">Dialog.Content</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Dialog.Header</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Edit Profile<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Dialog.Close</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog.Header</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">Dialog.Body</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Name&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Email&quot;</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Bio&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog.Body</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">Dialog.Footer</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Dialog.Close</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;secondary-btn&quot;</span>&gt;</span>Cancel<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog.Close</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;primary-btn&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleSave}</span>&gt;</span>
            Save Changes
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog.Footer</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog.Content</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog</span>&gt;</span></span>
  );
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="import React, { 
  createContext, 
  useContext, 
  useState, 
  useEffect, 
  ReactNode, 
  MouseEvent,
  KeyboardEvent
} from &apos;react&apos;;

interface DialogContextType {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  loading: boolean;
  setLoading: (loading: boolean) => void;
  open: () => void;
  close: () => void;
  showLoading: () => void;
  hideLoading: () => void;
}

const DialogContext = createContext<DialogContextType | undefined>(undefined);

function useDialogContext(): DialogContextType {
  const context = useContext(DialogContext);
  if (!context) {
    throw new Error(&apos;Dialog compound components must be used within Dialog&apos;);
  }
  return context;
}

interface DialogProps {
  children: ReactNode;
  onClose?: () => void;
}

function Dialog({ children, onClose }: DialogProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [loading, setLoading] = useState(false);

  const contextValue: DialogContextType = {
    isOpen,
    setIsOpen,
    loading,
    setLoading,
    open: () => setIsOpen(true),
    close: () => {
      setIsOpen(false);
      onClose?.();
    },
    showLoading: () => setLoading(true),
    hideLoading: () => setLoading(false)
  };

  // Handle escape key
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent<Document>) => {
      if (e.key === &apos;Escape&apos; && isOpen) {
        contextValue.close();
      }
    };

    if (isOpen) {
      document.addEventListener(&apos;keydown&apos;, handleEscape as any);
      document.body.style.overflow = &apos;hidden&apos;;
    }

    return () => {
      document.removeEventListener(&apos;keydown&apos;, handleEscape as any);
      document.body.style.overflow = &apos;unset&apos;;
    };
  }, [isOpen, contextValue]);

  return (
    <DialogContext.Provider value={contextValue}>
      {children}
    </DialogContext.Provider>
  );
}

interface DialogTriggerProps {
  children: ReactNode;
  asChild?: boolean;
}

Dialog.Trigger = function DialogTrigger({ children, asChild = false }: DialogTriggerProps) {
  const { open } = useDialogContext();
  
  if (asChild && React.isValidElement(children)) {
    return React.cloneElement(children, { onClick: open });
  }
  
  return <button onClick={open}>{children}</button>;
};

interface DialogContentProps {
  children: ReactNode;
  className?: string;
}

Dialog.Content = function DialogContent({ children, className = &apos;&apos; }: DialogContentProps) {
  const { isOpen, close } = useDialogContext();
  
  if (!isOpen) return null;
  
  const handleOverlayClick = (e: MouseEvent<HTMLDivElement>) => {
    if (e.target === e.currentTarget) {
      close();
    }
  };
  
  return (
    <div className={`dialog-overlay ${className}`} onClick={handleOverlayClick}>
      <div className=&quot;dialog-content&quot;>
        {children}
      </div>
    </div>
  );
};

interface DialogHeaderProps {
  children: ReactNode;
}

Dialog.Header = function DialogHeader({ children }: DialogHeaderProps) {
  return <div className=&quot;dialog-header&quot;>{children}</div>;
};

interface DialogBodyProps {
  children: ReactNode;
}

Dialog.Body = function DialogBody({ children }: DialogBodyProps) {
  const { loading } = useDialogContext();
  
  return (
    <div className=&quot;dialog-body&quot;>
      {loading && <div className=&quot;loading-spinner&quot;>Loading...</div>}
      {children}
    </div>
  );
};

interface DialogFooterProps {
  children: ReactNode;
}

Dialog.Footer = function DialogFooter({ children }: DialogFooterProps) {
  return <div className=&quot;dialog-footer&quot;>{children}</div>;
};

interface DialogCloseProps {
  children?: ReactNode;
}

Dialog.Close = function DialogClose({ children }: DialogCloseProps) {
  const { close } = useDialogContext();
  
  return (
    <button className=&quot;dialog-close&quot; onClick={close}>
      {children || &apos;Ã—&apos;}
    </button>
  );
};

// Usage example with full type safety
function UserProfile() {
  const handleSave = async (): Promise<void> => {
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 2000));
  };

  return (
    <Dialog onClose={() => console.log(&apos;Dialog closed&apos;)}>
      <Dialog.Trigger>
        <button className=&quot;primary-btn&quot;>Edit Profile</button>
      </Dialog.Trigger>
      
      <Dialog.Content>
        <Dialog.Header>
          <h2>Edit Profile</h2>
          <Dialog.Close />
        </Dialog.Header>
        
        <Dialog.Body>
          <form>
            <input type=&quot;text&quot; placeholder=&quot;Name&quot; />
            <input type=&quot;email&quot; placeholder=&quot;Email&quot; />
            <textarea placeholder=&quot;Bio&quot;></textarea>
          </form>
        </Dialog.Body>
        
        <Dialog.Footer>
          <Dialog.Close>
            <button className=&quot;secondary-btn&quot;>Cancel</button>
          </Dialog.Close>
          <button className=&quot;primary-btn&quot; onClick={handleSave}>
            Save Changes
          </button>
        </Dialog.Footer>
      </Dialog.Content>
    </Dialog>
  );
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h3>2. Advanced Data Table Component</h3>
<p>For more complex scenarios, here's a data table implementation that showcases the pattern's scalability:</p>

<div style="position: relative">
	<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { 
  createContext, 
  useContext, 
  useState, 
  useMemo, 
  <span class="hljs-title class_">ReactNode</span> 
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-comment">// Generic type for table data</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableData</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;
  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
}

<span class="hljs-keyword">type</span> <span class="hljs-title class_">SortDirection</span> = <span class="hljs-string">&#x27;asc&#x27;</span> | <span class="hljs-string">&#x27;desc&#x27;</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableContextType</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableData</span>&gt; {
  <span class="hljs-attr">data</span>: T[];
  <span class="hljs-attr">originalData</span>: T[];
  <span class="hljs-attr">sortColumn</span>: keyof T | <span class="hljs-literal">null</span>;
  <span class="hljs-attr">sortDirection</span>: <span class="hljs-title class_">SortDirection</span>;
  <span class="hljs-attr">filters</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;;
  <span class="hljs-attr">selectedRows</span>: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;;
  <span class="hljs-attr">sort</span>: <span class="hljs-function">(<span class="hljs-params">column: keyof T</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">filter</span>: <span class="hljs-function">(<span class="hljs-params">column: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">selectRow</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">selectAllRows</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">clearSelection</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">TableContext</span> = createContext&lt;<span class="hljs-title class_">TableContextType</span>&lt;<span class="hljs-built_in">any</span>&gt; | <span class="hljs-literal">undefined</span>&gt;(<span class="hljs-literal">undefined</span>);

<span class="hljs-keyword">function</span> useTableContext&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableData</span>&gt;(): <span class="hljs-title class_">TableContextType</span>&lt;T&gt; {
  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">TableContext</span>);
  <span class="hljs-keyword">if</span> (!context) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Table compound components must be used within Table&#x27;</span>);
  }
  <span class="hljs-keyword">return</span> context;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableProps</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableData</span>&gt; {
  <span class="hljs-attr">data</span>: T[];
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title class_">Table</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableData</span>&gt;({ data, children }: <span class="hljs-title class_">TableProps</span>&lt;T&gt;) {
  <span class="hljs-keyword">const</span> [sortColumn, setSortColumn] = useState&lt;keyof T | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [sortDirection, setSortDirection] = useState&lt;<span class="hljs-title class_">SortDirection</span>&gt;(<span class="hljs-string">&#x27;asc&#x27;</span>);
  <span class="hljs-keyword">const</span> [filters, setFilters] = useState&lt;<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;&gt;({});
  <span class="hljs-keyword">const</span> [selectedRows, setSelectedRows] = useState&lt;<span class="hljs-title class_">Set</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>());

  <span class="hljs-keyword">const</span> processedData = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> result = [...data];

    <span class="hljs-comment">// Apply filters</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(filters).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[column, value]</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (value) {
        result = result.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">row</span> =&gt;</span> 
          <span class="hljs-title class_">String</span>(row[column]).<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">includes</span>(value.<span class="hljs-title function_">toLowerCase</span>())
        );
      }
    });

    <span class="hljs-comment">// Apply sorting</span>
    <span class="hljs-keyword">if</span> (sortColumn) {
      result.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> aVal = a[sortColumn];
        <span class="hljs-keyword">const</span> bVal = b[sortColumn];
        <span class="hljs-keyword">const</span> modifier = sortDirection === <span class="hljs-string">&#x27;asc&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;
        
        <span class="hljs-keyword">if</span> (aVal &lt; bVal) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> * modifier;
        <span class="hljs-keyword">if</span> (aVal &gt; bVal) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> * modifier;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      });
    }

    <span class="hljs-keyword">return</span> result;
  }, [data, filters, sortColumn, sortDirection]);

  <span class="hljs-keyword">const</span> <span class="hljs-attr">contextValue</span>: <span class="hljs-title class_">TableContextType</span>&lt;T&gt; = {
    <span class="hljs-attr">data</span>: processedData,
    <span class="hljs-attr">originalData</span>: data,
    sortColumn,
    sortDirection,
    filters,
    selectedRows,
    <span class="hljs-attr">sort</span>: <span class="hljs-function">(<span class="hljs-params">column: keyof T</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (sortColumn === column) {
        <span class="hljs-title function_">setSortDirection</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev === <span class="hljs-string">&#x27;asc&#x27;</span> ? <span class="hljs-string">&#x27;desc&#x27;</span> : <span class="hljs-string">&#x27;asc&#x27;</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">setSortColumn</span>(column);
        <span class="hljs-title function_">setSortDirection</span>(<span class="hljs-string">&#x27;asc&#x27;</span>);
      }
    },
    <span class="hljs-attr">filter</span>: <span class="hljs-function">(<span class="hljs-params">column: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
      <span class="hljs-title function_">setFilters</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> ({ ...prev, [column]: value }));
    },
    <span class="hljs-attr">selectRow</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) =&gt;</span> {
      <span class="hljs-title function_">setSelectedRows</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(prev);
        <span class="hljs-keyword">if</span> (newSet.<span class="hljs-title function_">has</span>(id)) {
          newSet.<span class="hljs-title function_">delete</span>(id);
        } <span class="hljs-keyword">else</span> {
          newSet.<span class="hljs-title function_">add</span>(id);
        }
        <span class="hljs-keyword">return</span> newSet;
      });
    },
    <span class="hljs-attr">selectAllRows</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setSelectedRows</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(processedData.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">row</span> =&gt;</span> row.<span class="hljs-property">id</span>)));
    },
    <span class="hljs-attr">clearSelection</span>: <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setSelectedRows</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>());
    }
  };

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TableContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{contextValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;table-container&quot;</span>&gt;</span>
        {children}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">TableContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableHeaderProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Table</span>.<span class="hljs-property">Header</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TableHeader</span>(<span class="hljs-params">{ children }: TableHeaderProps</span>) {
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">thead</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;table-header&quot;</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span></span>;
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableBodyProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Table</span>.<span class="hljs-property">Body</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TableBody</span>(<span class="hljs-params">{ children }: TableBodyProps</span>) {
  <span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useTableContext</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;table-body&quot;</span>&gt;</span>
      {data.map((row, index) =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">TableRowProvider</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{row.id}</span> <span class="hljs-attr">row</span>=<span class="hljs-string">{row}</span> <span class="hljs-attr">index</span>=<span class="hljs-string">{index}</span>&gt;</span>
          {children}
        <span class="hljs-tag">&lt;/<span class="hljs-name">TableRowProvider</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableRowProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Table</span>.<span class="hljs-property">Row</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TableRow</span>(<span class="hljs-params">{ children }: TableRowProps</span>) {
  <span class="hljs-keyword">const</span> { row, index } = <span class="hljs-title function_">useTableRowContext</span>();
  <span class="hljs-keyword">const</span> { selectedRows } = <span class="hljs-title function_">useTableContext</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> 
      <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">table-row</span> ${<span class="hljs-attr">selectedRows.has</span>(<span class="hljs-attr">row.id</span>) ? &#x27;<span class="hljs-attr">selected</span>&#x27; <span class="hljs-attr">:</span> &#x27;&#x27;}`}
      <span class="hljs-attr">data-index</span>=<span class="hljs-string">{index}</span>
    &gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableHeaderCellProps</span> {
  column?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  sortable?: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-title class_">Table</span>.<span class="hljs-property">HeaderCell</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TableHeaderCell</span>(<span class="hljs-params">{ 
  column, 
  children, 
  sortable = <span class="hljs-literal">false</span> 
}: TableHeaderCellProps</span>) {
  <span class="hljs-keyword">const</span> { sort, sortColumn, sortDirection } = <span class="hljs-title function_">useTableContext</span>();
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">if</span> (sortable &amp;&amp; column) {
      <span class="hljs-title function_">sort</span>(column);
    }
  };

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">th</span> 
      <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">table-header-cell</span> ${<span class="hljs-attr">sortable</span> ? &#x27;<span class="hljs-attr">sortable</span>&#x27; <span class="hljs-attr">:</span> &#x27;&#x27;}`}
      <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>
    &gt;</span>
      {children}
      {sortable &amp;&amp; sortColumn === column &amp;&amp; (
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;sort-indicator&quot;</span>&gt;</span>
          {sortDirection === &#x27;asc&#x27; ? &#x27;â†‘&#x27; : &#x27;â†“&#x27;}
        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableCellProps</span> {
  column?: <span class="hljs-built_in">string</span>;
  children?: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">Table</span>.<span class="hljs-property">Cell</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TableCell</span>(<span class="hljs-params">{ column, children }: TableCellProps</span>) {
  <span class="hljs-keyword">const</span> { row } = <span class="hljs-title function_">useTableRowContext</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;table-cell&quot;</span>&gt;</span>
      {children || (column ? row[column] : &#x27;&#x27;)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span>
  );
};

<span class="hljs-title class_">Table</span>.<span class="hljs-property">SelectCell</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TableSelectCell</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> { row } = <span class="hljs-title function_">useTableRowContext</span>();
  <span class="hljs-keyword">const</span> { selectedRows, selectRow } = <span class="hljs-title function_">useTableContext</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;table-select-cell&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>
        <span class="hljs-attr">checked</span>=<span class="hljs-string">{selectedRows.has(row.id)}</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{()</span> =&gt;</span> selectRow(row.id)}
      /&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableFilterProps</span> {
  <span class="hljs-attr">column</span>: <span class="hljs-built_in">string</span>;
  placeholder?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-title class_">Table</span>.<span class="hljs-property">Filter</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TableFilter</span>(<span class="hljs-params">{ column, placeholder }: TableFilterProps</span>) {
  <span class="hljs-keyword">const</span> { filters, filter } = <span class="hljs-title function_">useTableContext</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>
      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>
      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">{placeholder}</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{filters[column]</span> || &#x27;&#x27;}
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> filter(column, e.target.value)}
      className=&quot;table-filter&quot;
    /&gt;</span>
  );
};

<span class="hljs-comment">// Row context for accessing current row data</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableRowContextType</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableData</span> = <span class="hljs-title class_">TableData</span>&gt; {
  <span class="hljs-attr">row</span>: T;
  <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">TableRowContext</span> = createContext&lt;<span class="hljs-title class_">TableRowContextType</span> | <span class="hljs-literal">undefined</span>&gt;(<span class="hljs-literal">undefined</span>);

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableRowProviderProps</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableData</span>&gt; {
  <span class="hljs-attr">row</span>: T;
  <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title class_">TableRowProvider</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableData</span>&gt;({ 
  row, 
  index, 
  children 
}: <span class="hljs-title class_">TableRowProviderProps</span>&lt;T&gt;) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TableRowContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">row</span>, <span class="hljs-attr">index</span> }}&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">TableRowContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> useTableRowContext&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableData</span> = <span class="hljs-title class_">TableData</span>&gt;(): <span class="hljs-title class_">TableRowContextType</span>&lt;T&gt; {
  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">TableRowContext</span>);
  <span class="hljs-keyword">if</span> (!context) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Table row components must be used within Table.Body&#x27;</span>);
  }
  <span class="hljs-keyword">return</span> context <span class="hljs-keyword">as</span> <span class="hljs-title class_">TableRowContextType</span>&lt;T&gt;;
}

<span class="hljs-comment">// Usage example with proper typing</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;Admin&#x27;</span> | <span class="hljs-string">&#x27;User&#x27;</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">UsersTable</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">users</span>: <span class="hljs-title class_">User</span>[] = [
    { <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;john@example.com&#x27;</span>, <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;Admin&#x27;</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jane Smith&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;jane@example.com&#x27;</span>, <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;User&#x27;</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob Johnson&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;bob@example.com&#x27;</span>, <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;User&#x27;</span> }
  ];

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;table-controls&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Table.Filter</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Filter by name...&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Table.Filter</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Filter by email...&quot;</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        &lt;Table<span class="hljs-tag">&lt;<span class="hljs-name">User</span>&gt;</span> data={users}&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">Table.Header</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">Table.HeaderCell</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> /&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">Table.HeaderCell</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">Table.HeaderCell</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">sortable</span>&gt;</span>
                Name
              <span class="hljs-tag">&lt;/<span class="hljs-name">Table.HeaderCell</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">Table.HeaderCell</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">sortable</span>&gt;</span>
                Email
              <span class="hljs-tag">&lt;/<span class="hljs-name">Table.HeaderCell</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">Table.HeaderCell</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;role&quot;</span>&gt;</span>
                Role
              <span class="hljs-tag">&lt;/<span class="hljs-name">Table.HeaderCell</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">Table.Header</span>&gt;</span>
          
          <span class="hljs-tag">&lt;<span class="hljs-name">Table.Body</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Table.Row</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">Table.SelectCell</span> /&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">Table.Cell</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">Table.Cell</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">Table.Cell</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;role&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;role-badge&quot;</span>&gt;</span>
                  {/* Custom rendering with full type safety */}
                <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">Table.Cell</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">Table.Row</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">Table.Body</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}
</span></code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="import React, { 
  createContext, 
  useContext, 
  useState, 
  useMemo, 
  ReactNode 
} from &apos;react&apos;;

// Generic type for table data
interface TableData {
  id: string | number;
  [key: string]: any;
}

type SortDirection = &apos;asc&apos; | &apos;desc&apos;;

interface TableContextType<T extends TableData> {
  data: T[];
  originalData: T[];
  sortColumn: keyof T | null;
  sortDirection: SortDirection;
  filters: Record<string, string>;
  selectedRows: Set<string | number>;
  sort: (column: keyof T) => void;
  filter: (column: string, value: string) => void;
  selectRow: (id: string | number) => void;
  selectAllRows: () => void;
  clearSelection: () => void;
}

const TableContext = createContext<TableContextType<any> | undefined>(undefined);

function useTableContext<T extends TableData>(): TableContextType<T> {
  const context = useContext(TableContext);
  if (!context) {
    throw new Error(&apos;Table compound components must be used within Table&apos;);
  }
  return context;
}

interface TableProps<T extends TableData> {
  data: T[];
  children: ReactNode;
}

function Table<T extends TableData>({ data, children }: TableProps<T>) {
  const [sortColumn, setSortColumn] = useState<keyof T | null>(null);
  const [sortDirection, setSortDirection] = useState<SortDirection>(&apos;asc&apos;);
  const [filters, setFilters] = useState<Record<string, string>>({});
  const [selectedRows, setSelectedRows] = useState<Set<string | number>>(new Set());

  const processedData = useMemo(() => {
    let result = [...data];

    // Apply filters
    Object.entries(filters).forEach(([column, value]) => {
      if (value) {
        result = result.filter(row => 
          String(row[column]).toLowerCase().includes(value.toLowerCase())
        );
      }
    });

    // Apply sorting
    if (sortColumn) {
      result.sort((a, b) => {
        const aVal = a[sortColumn];
        const bVal = b[sortColumn];
        const modifier = sortDirection === &apos;asc&apos; ? 1 : -1;
        
        if (aVal < bVal) return -1 * modifier;
        if (aVal > bVal) return 1 * modifier;
        return 0;
      });
    }

    return result;
  }, [data, filters, sortColumn, sortDirection]);

  const contextValue: TableContextType<T> = {
    data: processedData,
    originalData: data,
    sortColumn,
    sortDirection,
    filters,
    selectedRows,
    sort: (column: keyof T) => {
      if (sortColumn === column) {
        setSortDirection(prev => prev === &apos;asc&apos; ? &apos;desc&apos; : &apos;asc&apos;);
      } else {
        setSortColumn(column);
        setSortDirection(&apos;asc&apos;);
      }
    },
    filter: (column: string, value: string) => {
      setFilters(prev => ({ ...prev, [column]: value }));
    },
    selectRow: (id: string | number) => {
      setSelectedRows(prev => {
        const newSet = new Set(prev);
        if (newSet.has(id)) {
          newSet.delete(id);
        } else {
          newSet.add(id);
        }
        return newSet;
      });
    },
    selectAllRows: () => {
      setSelectedRows(new Set(processedData.map(row => row.id)));
    },
    clearSelection: () => {
      setSelectedRows(new Set());
    }
  };

  return (
    <TableContext.Provider value={contextValue}>
      <div className=&quot;table-container&quot;>
        {children}
      </div>
    </TableContext.Provider>
  );
}

interface TableHeaderProps {
  children: ReactNode;
}

Table.Header = function TableHeader({ children }: TableHeaderProps) {
  return <thead className=&quot;table-header&quot;>{children}</thead>;
};

interface TableBodyProps {
  children: ReactNode;
}

Table.Body = function TableBody({ children }: TableBodyProps) {
  const { data } = useTableContext();
  
  return (
    <tbody className=&quot;table-body&quot;>
      {data.map((row, index) => (
        <TableRowProvider key={row.id} row={row} index={index}>
          {children}
        </TableRowProvider>
      ))}
    </tbody>
  );
};

interface TableRowProps {
  children: ReactNode;
}

Table.Row = function TableRow({ children }: TableRowProps) {
  const { row, index } = useTableRowContext();
  const { selectedRows } = useTableContext();
  
  return (
    <tr 
      className={`table-row ${selectedRows.has(row.id) ? &apos;selected&apos; : &apos;&apos;}`}
      data-index={index}
    >
      {children}
    </tr>
  );
};

interface TableHeaderCellProps {
  column?: string;
  children: ReactNode;
  sortable?: boolean;
}

Table.HeaderCell = function TableHeaderCell({ 
  column, 
  children, 
  sortable = false 
}: TableHeaderCellProps) {
  const { sort, sortColumn, sortDirection } = useTableContext();
  
  const handleClick = () => {
    if (sortable && column) {
      sort(column);
    }
  };

  return (
    <th 
      className={`table-header-cell ${sortable ? &apos;sortable&apos; : &apos;&apos;}`}
      onClick={handleClick}
    >
      {children}
      {sortable && sortColumn === column && (
        <span className=&quot;sort-indicator&quot;>
          {sortDirection === &apos;asc&apos; ? &apos;â†‘&apos; : &apos;â†“&apos;}
        </span>
      )}
    </th>
  );
};

interface TableCellProps {
  column?: string;
  children?: ReactNode;
}

Table.Cell = function TableCell({ column, children }: TableCellProps) {
  const { row } = useTableRowContext();
  
  return (
    <td className=&quot;table-cell&quot;>
      {children || (column ? row[column] : &apos;&apos;)}
    </td>
  );
};

Table.SelectCell = function TableSelectCell() {
  const { row } = useTableRowContext();
  const { selectedRows, selectRow } = useTableContext();
  
  return (
    <td className=&quot;table-select-cell&quot;>
      <input
        type=&quot;checkbox&quot;
        checked={selectedRows.has(row.id)}
        onChange={() => selectRow(row.id)}
      />
    </td>
  );
};

interface TableFilterProps {
  column: string;
  placeholder?: string;
}

Table.Filter = function TableFilter({ column, placeholder }: TableFilterProps) {
  const { filters, filter } = useTableContext();
  
  return (
    <input
      type=&quot;text&quot;
      placeholder={placeholder}
      value={filters[column] || &apos;&apos;}
      onChange={(e) => filter(column, e.target.value)}
      className=&quot;table-filter&quot;
    />
  );
};

// Row context for accessing current row data
interface TableRowContextType<T extends TableData = TableData> {
  row: T;
  index: number;
}

const TableRowContext = createContext<TableRowContextType | undefined>(undefined);

interface TableRowProviderProps<T extends TableData> {
  row: T;
  index: number;
  children: ReactNode;
}

function TableRowProvider<T extends TableData>({ 
  row, 
  index, 
  children 
}: TableRowProviderProps<T>) {
  return (
    <TableRowContext.Provider value={{ row, index }}>
      {children}
    </TableRowContext.Provider>
  );
}

function useTableRowContext<T extends TableData = TableData>(): TableRowContextType<T> {
  const context = useContext(TableRowContext);
  if (!context) {
    throw new Error(&apos;Table row components must be used within Table.Body&apos;);
  }
  return context as TableRowContextType<T>;
}

// Usage example with proper typing
interface User {
  id: string;
  name: string;
  email: string;
  role: &apos;Admin&apos; | &apos;User&apos;;
}

function UsersTable() {
  const users: User[] = [
    { id: &apos;1&apos;, name: &apos;John Doe&apos;, email: &apos;john@example.com&apos;, role: &apos;Admin&apos; },
    { id: &apos;2&apos;, name: &apos;Jane Smith&apos;, email: &apos;jane@example.com&apos;, role: &apos;User&apos; },
    { id: &apos;3&apos;, name: &apos;Bob Johnson&apos;, email: &apos;bob@example.com&apos;, role: &apos;User&apos; }
  ];

  return (
    <div>
      <div className=&quot;table-controls&quot;>
        <Table.Filter column=&quot;name&quot; placeholder=&quot;Filter by name...&quot; />
        <Table.Filter column=&quot;email&quot; placeholder=&quot;Filter by email...&quot; />
      </div>
      
      <table>
        <Table<User> data={users}>
          <Table.Header>
            <tr>
              <Table.HeaderCell>
                <input type=&quot;checkbox&quot; />
              </Table.HeaderCell>
              <Table.HeaderCell column=&quot;name&quot; sortable>
                Name
              </Table.HeaderCell>
              <Table.HeaderCell column=&quot;email&quot; sortable>
                Email
              </Table.HeaderCell>
              <Table.HeaderCell column=&quot;role&quot;>
                Role
              </Table.HeaderCell>
            </tr>
          </Table.Header>
          
          <Table.Body>
            <Table.Row>
              <Table.SelectCell />
              <Table.Cell column=&quot;name&quot; />
              <Table.Cell column=&quot;email&quot; />
              <Table.Cell column=&quot;role&quot;>
                <span className=&quot;role-badge&quot;>
                  {/* Custom rendering with full type safety */}
                </span>
              </Table.Cell>
            </Table.Row>
          </Table.Body>
        </Table>
      </div>
    </div>
  );
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h2>Performance Considerations</h2>
<p>While the compound pattern offers excellent developer experience, it's important to consider performance implications:</p>
<h3>Context Performance Optimization</h3>

<div style="position: relative">
	<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { 
  createContext, 
  useContext, 
  useMemo, 
  useCallback, 
  useState,
  <span class="hljs-title class_">ReactNode</span> 
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuState</span> {
  <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">activeItem</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuActions</span> {
  <span class="hljs-attr">toggle</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">selectItem</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">MenuStateContext</span> = createContext&lt;<span class="hljs-title class_">MenuState</span> | <span class="hljs-literal">undefined</span>&gt;(<span class="hljs-literal">undefined</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MenuActionsContext</span> = createContext&lt;<span class="hljs-title class_">MenuActions</span> | <span class="hljs-literal">undefined</span>&gt;(<span class="hljs-literal">undefined</span>);

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">OptimizedMenuProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">OptimizedMenu</span>(<span class="hljs-params">{ children }: OptimizedMenuProps</span>) {
  <span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [activeItem, setActiveItem] = useState&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// Separate state context (changes frequently)</span>
  <span class="hljs-keyword">const</span> stateContextValue = <span class="hljs-title function_">useMemo</span>((): <span class="hljs-function"><span class="hljs-params">MenuState</span> =&gt;</span> ({
    isOpen,
    activeItem
  }), [isOpen, activeItem]);

  <span class="hljs-comment">// Separate actions context (stable)</span>
  <span class="hljs-keyword">const</span> actionsContextValue = <span class="hljs-title function_">useMemo</span>((): <span class="hljs-function"><span class="hljs-params">MenuActions</span> =&gt;</span> ({
    <span class="hljs-attr">toggle</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> !prev),
    <span class="hljs-attr">selectItem</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-title function_">setActiveItem</span>(id)
  }), []);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MenuStateContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{stateContextValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">MenuActionsContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{actionsContextValue}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">MenuActionsContext.Provider</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">MenuStateContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// Separate hooks for better performance</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useMenuState</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MenuState</span> {
  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MenuStateContext</span>);
  <span class="hljs-keyword">if</span> (!context) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;useMenuState must be used within OptimizedMenu&#x27;</span>);
  }
  <span class="hljs-keyword">return</span> context;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useMenuActions</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MenuActions</span> {
  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MenuActionsContext</span>);
  <span class="hljs-keyword">if</span> (!context) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;useMenuActions must be used within OptimizedMenu&#x27;</span>);
  }
  <span class="hljs-keyword">return</span> context;
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="import React, { 
  createContext, 
  useContext, 
  useMemo, 
  useCallback, 
  useState,
  ReactNode 
} from &apos;react&apos;;

interface MenuState {
  isOpen: boolean;
  activeItem: string | null;
}

interface MenuActions {
  toggle: () => void;
  selectItem: (id: string) => void;
}

const MenuStateContext = createContext<MenuState | undefined>(undefined);
const MenuActionsContext = createContext<MenuActions | undefined>(undefined);

interface OptimizedMenuProps {
  children: ReactNode;
}

function OptimizedMenu({ children }: OptimizedMenuProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [activeItem, setActiveItem] = useState<string | null>(null);

  // Separate state context (changes frequently)
  const stateContextValue = useMemo((): MenuState => ({
    isOpen,
    activeItem
  }), [isOpen, activeItem]);

  // Separate actions context (stable)
  const actionsContextValue = useMemo((): MenuActions => ({
    toggle: () => setIsOpen(prev => !prev),
    selectItem: (id: string) => setActiveItem(id)
  }), []);

  return (
    <MenuStateContext.Provider value={stateContextValue}>
      <MenuActionsContext.Provider value={actionsContextValue}>
        <div className=&quot;menu&quot;>{children}</div>
      </MenuActionsContext.Provider>
    </MenuStateContext.Provider>
  );
}

// Separate hooks for better performance
function useMenuState(): MenuState {
  const context = useContext(MenuStateContext);
  if (!context) {
    throw new Error(&apos;useMenuState must be used within OptimizedMenu&apos;);
  }
  return context;
}

function useMenuActions(): MenuActions {
  const context = useContext(MenuActionsContext);
  if (!context) {
    throw new Error(&apos;useMenuActions must be used within OptimizedMenu&apos;);
  }
  return context;
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h3>Best Practices for Performance</h3>
<ol>
<li><strong>Split Contexts</strong>: Separate frequently changing state from stable actions</li>
<li><strong>Memoize Context Values</strong>: Use <code>useMemo</code> to prevent unnecessary re-renders</li>
<li><strong>Optimize Child Components</strong>: Use <code>React.memo</code> for compound components when appropriate</li>
<li><strong>Lazy Evaluation</strong>: Only compute expensive values when needed</li>
<li><strong>Proper TypeScript</strong>: Use generics and proper typing for better performance and DX</li>
</ol>
<h2>When to Use the Compound Pattern</h2>
<p>The compound pattern shines in specific scenarios:</p>
<h3>Ideal Use Cases</h3>
<ul>
<li><strong>Related Component Groups</strong>: When components naturally work together (tabs, accordion, dropdown)</li>
<li><strong>Complex State Management</strong>: When multiple components need to share and synchronize state</li>
<li><strong>Flexible APIs</strong>: When users need control over component arrangement and styling</li>
<li><strong>Design Systems</strong>: When building reusable component libraries with TypeScript</li>
<li><strong>Library Development</strong>: When creating components that need to be highly composable</li>
</ul>
<h3>When to Avoid</h3>
<ul>
<li><strong>Simple Components</strong>: When prop drilling involves only one or two levels</li>
<li><strong>Performance-Critical Paths</strong>: When context updates would cause expensive re-renders</li>
<li><strong>Unrelated Components</strong>: When components don't naturally belong together</li>
<li><strong>Over-Engineering</strong>: When simpler patterns would suffice</li>
</ul>
<h2>Comparison with Other Patterns</h2>
<h3>Compound Pattern vs. Render Props</h3>

<div style="position: relative">
	<pre><code class="hljs language-tsx"><span class="hljs-comment">// Render Props approach</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuRenderProps</span> {
  <span class="hljs-attr">isOpen</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">setIsOpen</span>: <span class="hljs-function">(<span class="hljs-params">isOpen: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">toggle</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MenuWithRenderProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-function">(<span class="hljs-params">props: MenuRenderProps</span>) =&gt;</span> <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MenuWithRenderProps</span>(<span class="hljs-params">{ children }: MenuWithRenderProps</span>) {
  <span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">children</span>({ 
    isOpen, 
    setIsOpen, 
    <span class="hljs-attr">toggle</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setIsOpen</span>(!isOpen) 
  });
}

<span class="hljs-comment">// Usage - less declarative</span>
&lt;<span class="hljs-title class_">MenuWithRenderProps</span>&gt;
  {<span class="hljs-function">(<span class="hljs-params">{ isOpen, toggle }</span>) =&gt;</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{toggle}</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      {isOpen &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )}
&lt;/<span class="hljs-title class_">MenuWithRenderProps</span>&gt;

<span class="hljs-comment">// Compound Pattern is more declarative and readable</span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Menu</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Button</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Menu.List</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.List</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Menu</span>&gt;</span></span>
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="// Render Props approach
interface MenuRenderProps {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  toggle: () => void;
}

interface MenuWithRenderProps {
  children: (props: MenuRenderProps) => ReactNode;
}

function MenuWithRenderProps({ children }: MenuWithRenderProps) {
  const [isOpen, setIsOpen] = useState(false);
  
  return children({ 
    isOpen, 
    setIsOpen, 
    toggle: () => setIsOpen(!isOpen) 
  });
}

// Usage - less declarative
<MenuWithRenderProps>
  {({ isOpen, toggle }) => (
    <div>
      <button onClick={toggle}>Toggle</button>
      {isOpen && <ul>...</ul>}
    </div>
  )}
</MenuWithRenderProps>

// Compound Pattern is more declarative and readable
<Menu>
  <Menu.Button>Toggle</Menu.Button>
  <Menu.List>...</Menu.List>
</Menu>
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h3>Compound Pattern vs. HOCs</h3>
<p>The compound pattern offers better composition and avoids the wrapper hell often associated with Higher-Order Components while providing excellent TypeScript support and better inference.</p>
<h1><strong>Extending the pattern: beyond composition</strong></h1>
<p>Once you've grasped the power of the Compound Pattern, it's time to push beyond. Here are some advanced techniques that can transform your components from simple building blocks into true user interface ecosystems.</p>
<h2>Auto-Detection of Child Components</h2>
<p>Sometimes exposing a declarative API isn't enough, we also need to be smart about how our components behave based on their structure. Using <code>React.Children</code> and traversal functions, we can create components that automatically adapt to their content.</p>

<div style="position: relative">
	<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">ReactNode</span>, <span class="hljs-title class_">ReactElement</span>, <span class="hljs-title class_">Children</span>, isValidElement } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">TabsProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  defaultValue?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Tabs</span>(<span class="hljs-params">{ children, defaultValue }: TabsProps</span>) {
  <span class="hljs-keyword">const</span> [activeTab, setActiveTab] = useState&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Auto-detect first tab if no default provided</span>
    <span class="hljs-keyword">if</span> (defaultValue) <span class="hljs-keyword">return</span> defaultValue;
    
    <span class="hljs-keyword">const</span> tabList = <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">toArray</span>(children).<span class="hljs-title function_">find</span>(
      (child): child is <span class="hljs-title class_">ReactElement</span> =&gt; 
        <span class="hljs-title function_">isValidElement</span>(child) &amp;&amp; child.<span class="hljs-property">type</span> === <span class="hljs-title class_">Tabs</span>.<span class="hljs-property">List</span>
    );
    
    <span class="hljs-keyword">if</span> (tabList) {
      <span class="hljs-keyword">const</span> firstTrigger = <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">toArray</span>(tabList.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>).<span class="hljs-title function_">find</span>(
        (child): child is <span class="hljs-title class_">ReactElement</span> =&gt; 
          <span class="hljs-title function_">isValidElement</span>(child) &amp;&amp; child.<span class="hljs-property">type</span> === <span class="hljs-title class_">Tabs</span>.<span class="hljs-property">Trigger</span>
      );
      
      <span class="hljs-keyword">return</span> firstTrigger?.<span class="hljs-property">props</span>.<span class="hljs-property">value</span> || <span class="hljs-string">&#x27;&#x27;</span>;
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
  });

  <span class="hljs-keyword">const</span> contextValue = {
    activeTab,
    setActiveTab,
    <span class="hljs-comment">// Auto-detect available tabs</span>
    <span class="hljs-attr">availableTabs</span>: <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> <span class="hljs-attr">tabs</span>: <span class="hljs-built_in">string</span>[] = [];
      
      <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">forEach</span>(children, <span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValidElement</span>(child) &amp;&amp; child.<span class="hljs-property">type</span> === <span class="hljs-title class_">Tabs</span>.<span class="hljs-property">Content</span>) {
          tabs.<span class="hljs-title function_">push</span>(child.<span class="hljs-property">props</span>.<span class="hljs-property">value</span>);
        }
      });
      
      <span class="hljs-keyword">return</span> tabs;
    }, [children])
  };

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TabsContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{contextValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;tabs&quot;</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">TabsContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-title class_">Tabs</span>.<span class="hljs-property">List</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TabsList</span>(<span class="hljs-params">{ children }: { children: ReactNode }</span>) {
  <span class="hljs-keyword">const</span> { availableTabs } = <span class="hljs-title function_">useTabsContext</span>();
  
  <span class="hljs-comment">// Auto-filter only valid triggers</span>
  <span class="hljs-keyword">const</span> validTriggers = <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">toArray</span>(children).<span class="hljs-title function_">filter</span>(
    (child): child is <span class="hljs-title class_">ReactElement</span> =&gt; 
      <span class="hljs-title function_">isValidElement</span>(child) &amp;&amp; 
      child.<span class="hljs-property">type</span> === <span class="hljs-title class_">Tabs</span>.<span class="hljs-property">Trigger</span> &amp;&amp;
      availableTabs.<span class="hljs-title function_">includes</span>(child.<span class="hljs-property">props</span>.<span class="hljs-property">value</span>)
  );

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;tabs-list&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;tablist&quot;</span>&gt;</span>
      {validTriggers}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-title class_">Tabs</span>.<span class="hljs-property">Trigger</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TabsTrigger</span>(<span class="hljs-params">{ 
  value,
  children 
}: { 
  value: <span class="hljs-built_in">string</span>; 
  children: ReactNode 
}</span>) {
  <span class="hljs-keyword">const</span> { activeTab, setActiveTab } = <span class="hljs-title function_">useTabsContext</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
      <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;tab&quot;</span>
      <span class="hljs-attr">aria-selected</span>=<span class="hljs-string">{activeTab</span> === <span class="hljs-string">value}</span>
      <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">tabs-trigger</span> ${<span class="hljs-attr">activeTab</span> === <span class="hljs-string">value</span> ? &#x27;<span class="hljs-attr">active</span>&#x27; <span class="hljs-attr">:</span> &#x27;&#x27;}`}
      <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setActiveTab(value)}
    &gt;
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
};

<span class="hljs-title class_">Tabs</span>.<span class="hljs-property">Content</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">TabsContent</span>(<span class="hljs-params">{ 
  value, 
  children 
}: { 
  value: <span class="hljs-built_in">string</span>; 
  children: ReactNode 
}</span>) {
  <span class="hljs-keyword">const</span> { activeTab } = <span class="hljs-title function_">useTabsContext</span>();
  
  <span class="hljs-keyword">if</span> (activeTab !== value) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;tabpanel&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;tabs-content&quot;</span>&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// Usage with auto-detection</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">SmartTabs</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Tabs</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;overview&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Tabs.List</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Tabs.Trigger</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;overview&quot;</span>&gt;</span>Overview<span class="hljs-tag">&lt;/<span class="hljs-name">Tabs.Trigger</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Tabs.Trigger</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;settings&quot;</span>&gt;</span>Settings<span class="hljs-tag">&lt;/<span class="hljs-name">Tabs.Trigger</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Tabs.Trigger</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;invalid&quot;</span>&gt;</span>Invalid<span class="hljs-tag">&lt;/<span class="hljs-name">Tabs.Trigger</span>&gt;</span> {/* Automatically filtered */}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Tabs.List</span>&gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">Tabs.Content</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;overview&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Overview Content<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Tabs.Content</span>&gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">Tabs.Content</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;settings&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Settings Content<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Tabs.Content</span>&gt;</span>
      
      {/* The &quot;invalid&quot; trigger has no corresponding content */}
    <span class="hljs-tag">&lt;/<span class="hljs-name">Tabs</span>&gt;</span></span>
  );
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="import React, { ReactNode, ReactElement, Children, isValidElement } from &apos;react&apos;;

interface TabsProps {
  children: ReactNode;
  defaultValue?: string;
}

function Tabs({ children, defaultValue }: TabsProps) {
  const [activeTab, setActiveTab] = useState<string>(() => {
    // Auto-detect first tab if no default provided
    if (defaultValue) return defaultValue;
    
    const tabList = Children.toArray(children).find(
      (child): child is ReactElement => 
        isValidElement(child) && child.type === Tabs.List
    );
    
    if (tabList) {
      const firstTrigger = Children.toArray(tabList.props.children).find(
        (child): child is ReactElement => 
          isValidElement(child) && child.type === Tabs.Trigger
      );
      
      return firstTrigger?.props.value || &apos;&apos;;
    }
    
    return &apos;&apos;;
  });

  const contextValue = {
    activeTab,
    setActiveTab,
    // Auto-detect available tabs
    availableTabs: useMemo(() => {
      const tabs: string[] = [];
      
      Children.forEach(children, (child) => {
        if (isValidElement(child) && child.type === Tabs.Content) {
          tabs.push(child.props.value);
        }
      });
      
      return tabs;
    }, [children])
  };

  return (
    <TabsContext.Provider value={contextValue}>
      <div className=&quot;tabs&quot;>{children}</div>
    </TabsContext.Provider>
  );
}

Tabs.List = function TabsList({ children }: { children: ReactNode }) {
  const { availableTabs } = useTabsContext();
  
  // Auto-filter only valid triggers
  const validTriggers = Children.toArray(children).filter(
    (child): child is ReactElement => 
      isValidElement(child) && 
      child.type === Tabs.Trigger &&
      availableTabs.includes(child.props.value)
  );

  return (
    <div className=&quot;tabs-list&quot; role=&quot;tablist&quot;>
      {validTriggers}
    </div>
  );
};

Tabs.Trigger = function TabsTrigger({ 
  value,
  children 
}: { 
  value: string; 
  children: ReactNode 
}) {
  const { activeTab, setActiveTab } = useTabsContext();
  
  return (
    <button
      role=&quot;tab&quot;
      aria-selected={activeTab === value}
      className={`tabs-trigger ${activeTab === value ? &apos;active&apos; : &apos;&apos;}`}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
};

Tabs.Content = function TabsContent({ 
  value, 
  children 
}: { 
  value: string; 
  children: ReactNode 
}) {
  const { activeTab } = useTabsContext();
  
  if (activeTab !== value) return null;
  
  return (
    <div role=&quot;tabpanel&quot; className=&quot;tabs-content&quot;>
      {children}
    </div>
  );
};

// Usage with auto-detection
function SmartTabs() {
  return (
    <Tabs defaultValue=&quot;overview&quot;>
      <Tabs.List>
        <Tabs.Trigger value=&quot;overview&quot;>Overview</Tabs.Trigger>
        <Tabs.Trigger value=&quot;settings&quot;>Settings</Tabs.Trigger>
        <Tabs.Trigger value=&quot;invalid&quot;>Invalid</Tabs.Trigger> {/* Automatically filtered */}
      </Tabs.List>
      
      <Tabs.Content value=&quot;overview&quot;>
        <h2>Overview Content</h2>
      </Tabs.Content>
      
      <Tabs.Content value=&quot;settings&quot;>
        <h2>Settings Content</h2>
      </Tabs.Content>
      
      {/* The &quot;invalid&quot; trigger has no corresponding content */}
    </Tabs>
  );
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h2>Context Overrides at Intermediate Levels</h2>
<p>One of the most powerful patterns is the ability to override compound component behavior at intermediate levels. This allows you to create nested components that can modify parent behavior without breaking the communication chain.</p>

<div style="position: relative">
	<pre><code class="hljs language-tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NestedMenuContextType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MenuContextType</span> {
  <span class="hljs-attr">level</span>: <span class="hljs-built_in">number</span>;
  parentContext?: <span class="hljs-title class_">MenuContextType</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">NestedMenuContext</span> = createContext&lt;<span class="hljs-title class_">NestedMenuContextType</span> | <span class="hljs-literal">undefined</span>&gt;(<span class="hljs-literal">undefined</span>);

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">SubmenuProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  <span class="hljs-attr">trigger</span>: <span class="hljs-title class_">ReactNode</span>;
  disabled?: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Submenu</span>(<span class="hljs-params">{ children, trigger, disabled = <span class="hljs-literal">false</span> }: SubmenuProps</span>) {
  <span class="hljs-keyword">const</span> parentContext = <span class="hljs-title function_">useMenuContext</span>();
  <span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  
  <span class="hljs-comment">// Override specific behaviors while preserving parent context</span>
  <span class="hljs-keyword">const</span> <span class="hljs-attr">nestedContextValue</span>: <span class="hljs-title class_">NestedMenuContextType</span> = {
    ...parentContext,
    <span class="hljs-attr">level</span>: (parentContext <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">level</span> + <span class="hljs-number">1</span> || <span class="hljs-number">1</span>,
    parentContext,
    isOpen,
    setIsOpen,
    <span class="hljs-attr">toggle</span>: <span class="hljs-function">() =&gt;</span> !disabled &amp;&amp; <span class="hljs-title function_">setIsOpen</span>(!isOpen),
    <span class="hljs-comment">// Preserve parent&#x27;s active item logic</span>
    <span class="hljs-attr">selectItem</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
      parentContext.<span class="hljs-title function_">selectItem</span>(id);
      <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// Close submenu when item is selected</span>
    }
  };

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NestedMenuContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{nestedContextValue}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">submenu</span> <span class="hljs-attr">level-</span>${<span class="hljs-attr">nestedContextValue.level</span>}`}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> 
          <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">submenu-trigger</span> ${<span class="hljs-attr">disabled</span> ? &#x27;<span class="hljs-attr">disabled</span>&#x27; <span class="hljs-attr">:</span> &#x27;&#x27;}`}
          <span class="hljs-attr">onClick</span>=<span class="hljs-string">{nestedContextValue.toggle}</span>
        &gt;</span>
          {trigger}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        
        {isOpen &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;submenu-content&quot;</span>&gt;</span>
            {children}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        )}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">NestedMenuContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// Hook that works with both normal and nested context</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useMenuOrNestedContext</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MenuContextType</span> | <span class="hljs-title class_">NestedMenuContextType</span> {
  <span class="hljs-keyword">const</span> nestedContext = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">NestedMenuContext</span>);
  <span class="hljs-keyword">const</span> menuContext = <span class="hljs-title function_">useMenuContext</span>();
  
  <span class="hljs-keyword">return</span> nestedContext || menuContext;
}

<span class="hljs-comment">// Usage with nested overrides</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">AdvancedMenu</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Menu</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Button</span>&gt;</span>Main Menu<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Menu.List</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">Submenu</span> <span class="hljs-attr">trigger</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">span</span>&gt;</span>Products â–¶<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>}&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;product-1&quot;</span>&gt;</span>Product 1<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;product-2&quot;</span>&gt;</span>Product 2<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
          
          <span class="hljs-tag">&lt;<span class="hljs-name">Submenu</span> <span class="hljs-attr">trigger</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">span</span>&gt;</span>Categories â–¶<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>}&gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat-1&quot;</span>&gt;</span>Category 1<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat-2&quot;</span>&gt;</span>Category 2<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">Submenu</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Submenu</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">Menu.Item</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">Menu.Item</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Menu.List</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Menu</span>&gt;</span></span>
  );
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="interface NestedMenuContextType extends MenuContextType {
  level: number;
  parentContext?: MenuContextType;
}

const NestedMenuContext = createContext<NestedMenuContextType | undefined>(undefined);

interface SubmenuProps {
  children: ReactNode;
  trigger: ReactNode;
  disabled?: boolean;
}

function Submenu({ children, trigger, disabled = false }: SubmenuProps) {
  const parentContext = useMenuContext();
  const [isOpen, setIsOpen] = useState(false);
  
  // Override specific behaviors while preserving parent context
  const nestedContextValue: NestedMenuContextType = {
    ...parentContext,
    level: (parentContext as any).level + 1 || 1,
    parentContext,
    isOpen,
    setIsOpen,
    toggle: () => !disabled && setIsOpen(!isOpen),
    // Preserve parent&apos;s active item logic
    selectItem: (id: string) => {
      parentContext.selectItem(id);
      setIsOpen(false); // Close submenu when item is selected
    }
  };

  return (
    <NestedMenuContext.Provider value={nestedContextValue}>
      <div className={`submenu level-${nestedContextValue.level}`}>
        <div 
          className={`submenu-trigger ${disabled ? &apos;disabled&apos; : &apos;&apos;}`}
          onClick={nestedContextValue.toggle}
        >
          {trigger}
        </div>
        
        {isOpen && (
          <div className=&quot;submenu-content&quot;>
            {children}
          </div>
        )}
      </div>
    </NestedMenuContext.Provider>
  );
}

// Hook that works with both normal and nested context
function useMenuOrNestedContext(): MenuContextType | NestedMenuContextType {
  const nestedContext = useContext(NestedMenuContext);
  const menuContext = useMenuContext();
  
  return nestedContext || menuContext;
}

// Usage with nested overrides
function AdvancedMenu() {
  return (
    <Menu>
      <Menu.Button>Main Menu</Menu.Button>
      <Menu.List>
        <Menu.Item id=&quot;home&quot;>Home</Menu.Item>
        
        <Submenu trigger={<span>Products â–¶</span>}>
          <Menu.Item id=&quot;product-1&quot;>Product 1</Menu.Item>
          <Menu.Item id=&quot;product-2&quot;>Product 2</Menu.Item>
          
          <Submenu trigger={<span>Categories â–¶</span>}>
            <Menu.Item id=&quot;cat-1&quot;>Category 1</Menu.Item>
            <Menu.Item id=&quot;cat-2&quot;>Category 2</Menu.Item>
          </Submenu>
        </Submenu>
        
        <Menu.Item id=&quot;about&quot;>About</Menu.Item>
      </Menu.List>
    </Menu>
  );
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h2>Dynamic Slots: The ShadCN/Radix Pattern</h2>
<p>The true power of the compound pattern emerges when we implement dynamic slots, allowing components to adapt and reorganize based on content. This is the secret behind the flexibility of libraries like Radix UI and ShadCN.</p>

<div style="position: relative">
	<pre><code class="hljs language-tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SlotProps</span> {
  children?: <span class="hljs-title class_">ReactNode</span>;
  asChild?: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-comment">// Primitive Slot component inspired by Radix</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Slot</span>(<span class="hljs-params">{ children, asChild = <span class="hljs-literal">false</span>, ...props }: SlotProps &amp; <span class="hljs-built_in">any</span></span>) {
  <span class="hljs-keyword">if</span> (asChild &amp;&amp; <span class="hljs-title class_">React</span>.<span class="hljs-title function_">isValidElement</span>(children)) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">cloneElement</span>(children, {
      ...props,
      ...children.<span class="hljs-property">props</span>,
      <span class="hljs-attr">className</span>: <span class="hljs-string">`<span class="hljs-subst">${props.className || <span class="hljs-string">&#x27;&#x27;</span>}</span> <span class="hljs-subst">${children.props.className || <span class="hljs-string">&#x27;&#x27;</span>}</span>`</span>.<span class="hljs-title function_">trim</span>()
    });
  }
  
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, props, children);
}

<span class="hljs-comment">// Advanced Dialog with dynamic slots</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogWithSlotsProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  modal?: <span class="hljs-built_in">boolean</span>;
  onOpenChange?: <span class="hljs-function">(<span class="hljs-params">open: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogWithSlots</span>(<span class="hljs-params">{ children, modal = <span class="hljs-literal">true</span>, onOpenChange }: DialogWithSlotsProps</span>) {
  <span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleOpenChange</span> = (<span class="hljs-params">open: <span class="hljs-built_in">boolean</span></span>) =&gt; {
    <span class="hljs-title function_">setIsOpen</span>(open);
    onOpenChange?.(open);
  };

  <span class="hljs-comment">// Detect and organize slots automatically</span>
  <span class="hljs-keyword">const</span> slots = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">result</span>: {
      trigger?: <span class="hljs-title class_">ReactElement</span>;
      content?: <span class="hljs-title class_">ReactElement</span>;
      overlay?: <span class="hljs-title class_">ReactElement</span>;
      portal?: <span class="hljs-title class_">ReactElement</span>;
    } = {};
    
    <span class="hljs-title class_">Children</span>.<span class="hljs-title function_">forEach</span>(children, <span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValidElement</span>(child)) {
        <span class="hljs-keyword">const</span> displayName = (child.<span class="hljs-property">type</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">displayName</span>;
        
        <span class="hljs-keyword">switch</span> (displayName) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DialogTrigger&#x27;</span>:
            result.<span class="hljs-property">trigger</span> = child;
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DialogContent&#x27;</span>:
            result.<span class="hljs-property">content</span> = child;
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DialogOverlay&#x27;</span>:
            result.<span class="hljs-property">overlay</span> = child;
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DialogPortal&#x27;</span>:
            result.<span class="hljs-property">portal</span> = child;
            <span class="hljs-keyword">break</span>;
        }
      }
    });
    
    <span class="hljs-keyword">return</span> result;
  }, [children]);

  <span class="hljs-keyword">const</span> contextValue = {
    isOpen,
    <span class="hljs-attr">onOpenChange</span>: handleOpenChange,
    modal,
    slots
  };

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DialogContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{contextValue}</span>&gt;</span>
      {slots.trigger}
      {isOpen &amp;&amp; (
        modal ? (
          <span class="hljs-tag">&lt;<span class="hljs-name">DialogPortal</span>&gt;</span>
            {slots.overlay}
            {slots.content}
          <span class="hljs-tag">&lt;/<span class="hljs-name">DialogPortal</span>&gt;</span>
        ) : (
          <span class="hljs-tag">&lt;&gt;</span>
            {slots.overlay}
            {slots.content}
          <span class="hljs-tag">&lt;/&gt;</span></span>
        )
      )}
    &lt;/<span class="hljs-title class_">DialogContext</span>.<span class="hljs-property">Provider</span>&gt;
  );
}

<span class="hljs-comment">// Dynamic slot components</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogTriggerProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  asChild?: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-title class_">DialogWithSlots</span>.<span class="hljs-property">Trigger</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogTrigger</span>(<span class="hljs-params">{ 
  children, 
  asChild = <span class="hljs-literal">false</span> 
}: DialogTriggerProps</span>) {
  <span class="hljs-keyword">const</span> { onOpenChange } = <span class="hljs-title function_">useDialogContext</span>();
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">onOpenChange</span>(<span class="hljs-literal">true</span>);
  
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Slot</span> <span class="hljs-attr">asChild</span>=<span class="hljs-string">{asChild}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">Slot</span>&gt;</span></span>
  );
};

<span class="hljs-title class_">DialogWithSlots</span>.<span class="hljs-property">Trigger</span>.<span class="hljs-property">displayName</span> = <span class="hljs-string">&#x27;DialogTrigger&#x27;</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogContentProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  className?: <span class="hljs-built_in">string</span>;
  onPointerDownOutside?: <span class="hljs-function">(<span class="hljs-params">event: Event</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  onEscapeKeyDown?: <span class="hljs-function">(<span class="hljs-params">event: KeyboardEvent</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-title class_">DialogWithSlots</span>.<span class="hljs-property">Content</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogContent</span>(<span class="hljs-params">{
  children,
  className,
  onPointerDownOutside,
  onEscapeKeyDown
}: DialogContentProps</span>) {
  <span class="hljs-keyword">const</span> { isOpen, onOpenChange, modal } = <span class="hljs-title function_">useDialogContext</span>();
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleEscape</span> = (<span class="hljs-params">e: KeyboardEvent</span>) =&gt; {
      <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;Escape&#x27;</span>) {
        onEscapeKeyDown?.(e);
        <span class="hljs-keyword">if</span> (!e.<span class="hljs-property">defaultPrevented</span>) {
          <span class="hljs-title function_">onOpenChange</span>(<span class="hljs-literal">false</span>);
        }
      }
    };

    <span class="hljs-keyword">if</span> (isOpen) {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, handleEscape);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>, handleEscape);
    };
  }, [isOpen, onOpenChange, onEscapeKeyDown]);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handlePointerDownOutside</span> = (<span class="hljs-params">e: Event</span>) =&gt; {
    onPointerDownOutside?.(e);
    <span class="hljs-keyword">if</span> (!e.<span class="hljs-property">defaultPrevented</span> &amp;&amp; modal) {
      <span class="hljs-title function_">onOpenChange</span>(<span class="hljs-literal">false</span>);
    }
  };

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
      <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">dialog-content</span> ${<span class="hljs-attr">className</span> || &#x27;&#x27;}`}
      <span class="hljs-attr">onPointerDown</span>=<span class="hljs-string">{(e)</span> =&gt;</span> {
        if (e.target === e.currentTarget) {
          handlePointerDownOutside(e.nativeEvent);
        }
      }}
    &gt;
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-title class_">DialogWithSlots</span>.<span class="hljs-property">Content</span>.<span class="hljs-property">displayName</span> = <span class="hljs-string">&#x27;DialogContent&#x27;</span>;

<span class="hljs-comment">// Portal component for rendering outside DOM hierarchy</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogPortalProps</span> {
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">ReactNode</span>;
  container?: <span class="hljs-title class_">Element</span>;
}

<span class="hljs-title class_">DialogWithSlots</span>.<span class="hljs-property">Portal</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogPortal</span>(<span class="hljs-params">{ 
  children, 
  container 
}: DialogPortalProps</span>) {
  <span class="hljs-keyword">const</span> [mounted, setMounted] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setMounted</span>(<span class="hljs-literal">true</span>);
  }, []);

  <span class="hljs-keyword">if</span> (!mounted) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createPortal</span>(
    children,
    container || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>
  );
};

<span class="hljs-title class_">DialogWithSlots</span>.<span class="hljs-property">Portal</span>.<span class="hljs-property">displayName</span> = <span class="hljs-string">&#x27;DialogPortal&#x27;</span>;

<span class="hljs-comment">// Overlay component</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">DialogOverlayProps</span> {
  className?: <span class="hljs-built_in">string</span>;
  children?: <span class="hljs-title class_">ReactNode</span>;
}

<span class="hljs-title class_">DialogWithSlots</span>.<span class="hljs-property">Overlay</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">DialogOverlay</span>(<span class="hljs-params">{ 
  className,
  children 
}: DialogOverlayProps</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">dialog-overlay</span> ${<span class="hljs-attr">className</span> || &#x27;&#x27;}`}&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-title class_">DialogWithSlots</span>.<span class="hljs-property">Overlay</span>.<span class="hljs-property">displayName</span> = <span class="hljs-string">&#x27;DialogOverlay&#x27;</span>;

<span class="hljs-comment">// Advanced usage with complete flexibility</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">FlexibleDialog</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DialogWithSlots</span> <span class="hljs-attr">modal</span> <span class="hljs-attr">onOpenChange</span>=<span class="hljs-string">{(open)</span> =&gt;</span> console.log(&#x27;Dialog:&#x27;, open)}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">DialogWithSlots.Trigger</span> <span class="hljs-attr">asChild</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;custom-trigger&quot;</span>&gt;</span>Open Advanced Dialog<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">DialogWithSlots.Trigger</span>&gt;</span>
      
      <span class="hljs-tag">&lt;<span class="hljs-name">DialogWithSlots.Portal</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">DialogWithSlots.Overlay</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;custom-overlay&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">DialogWithSlots.Content</span> 
          <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;custom-content&quot;</span>
          <span class="hljs-attr">onEscapeKeyDown</span>=<span class="hljs-string">{(e)</span> =&gt;</span> {
            console.log(&#x27;Escape pressed&#x27;);
            // Could prevent default to keep dialog open
          }}
          onPointerDownOutside={(e) =&gt; {
            console.log(&#x27;Clicked outside&#x27;);
            // Could prevent default to keep dialog open
          }}
        &gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Advanced Dialog<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This dialog uses dynamic slots and advanced composition patterns.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          
          <span class="hljs-tag">&lt;<span class="hljs-name">DialogWithSlots.Trigger</span> <span class="hljs-attr">asChild</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">DialogWithSlots.Trigger</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">DialogWithSlots.Content</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">DialogWithSlots.Portal</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">DialogWithSlots</span>&gt;</span></span>
  );
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="interface SlotProps {
  children?: ReactNode;
  asChild?: boolean;
}

// Primitive Slot component inspired by Radix
function Slot({ children, asChild = false, ...props }: SlotProps & any) {
  if (asChild && React.isValidElement(children)) {
    return React.cloneElement(children, {
      ...props,
      ...children.props,
      className: `${props.className || &apos;&apos;} ${children.props.className || &apos;&apos;}`.trim()
    });
  }
  
  return React.createElement(&apos;div&apos;, props, children);
}

// Advanced Dialog with dynamic slots
interface DialogWithSlotsProps {
  children: ReactNode;
  modal?: boolean;
  onOpenChange?: (open: boolean) => void;
}

function DialogWithSlots({ children, modal = true, onOpenChange }: DialogWithSlotsProps) {
  const [isOpen, setIsOpen] = useState(false);
  
  const handleOpenChange = (open: boolean) => {
    setIsOpen(open);
    onOpenChange?.(open);
  };

  // Detect and organize slots automatically
  const slots = useMemo(() => {
    const result: {
      trigger?: ReactElement;
      content?: ReactElement;
      overlay?: ReactElement;
      portal?: ReactElement;
    } = {};
    
    Children.forEach(children, (child) => {
      if (isValidElement(child)) {
        const displayName = (child.type as any).displayName;
        
        switch (displayName) {
          case &apos;DialogTrigger&apos;:
            result.trigger = child;
            break;
          case &apos;DialogContent&apos;:
            result.content = child;
            break;
          case &apos;DialogOverlay&apos;:
            result.overlay = child;
            break;
          case &apos;DialogPortal&apos;:
            result.portal = child;
            break;
        }
      }
    });
    
    return result;
  }, [children]);

  const contextValue = {
    isOpen,
    onOpenChange: handleOpenChange,
    modal,
    slots
  };

  return (
    <DialogContext.Provider value={contextValue}>
      {slots.trigger}
      {isOpen && (
        modal ? (
          <DialogPortal>
            {slots.overlay}
            {slots.content}
          </DialogPortal>
        ) : (
          <>
            {slots.overlay}
            {slots.content}
          </>
        )
      )}
    </DialogContext.Provider>
  );
}

// Dynamic slot components
interface DialogTriggerProps {
  children: ReactNode;
  asChild?: boolean;
}

DialogWithSlots.Trigger = function DialogTrigger({ 
  children, 
  asChild = false 
}: DialogTriggerProps) {
  const { onOpenChange } = useDialogContext();
  
  const handleClick = () => onOpenChange(true);
  
  return (
    <Slot asChild={asChild} onClick={handleClick}>
      {children}
    </Slot>
  );
};

DialogWithSlots.Trigger.displayName = &apos;DialogTrigger&apos;;

interface DialogContentProps {
  children: ReactNode;
  className?: string;
  onPointerDownOutside?: (event: Event) => void;
  onEscapeKeyDown?: (event: KeyboardEvent) => void;
}

DialogWithSlots.Content = function DialogContent({
  children,
  className,
  onPointerDownOutside,
  onEscapeKeyDown
}: DialogContentProps) {
  const { isOpen, onOpenChange, modal } = useDialogContext();
  
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === &apos;Escape&apos;) {
        onEscapeKeyDown?.(e);
        if (!e.defaultPrevented) {
          onOpenChange(false);
        }
      }
    };

    if (isOpen) {
      document.addEventListener(&apos;keydown&apos;, handleEscape);
    }

    return () => {
      document.removeEventListener(&apos;keydown&apos;, handleEscape);
    };
  }, [isOpen, onOpenChange, onEscapeKeyDown]);

  const handlePointerDownOutside = (e: Event) => {
    onPointerDownOutside?.(e);
    if (!e.defaultPrevented && modal) {
      onOpenChange(false);
    }
  };

  return (
    <div
      className={`dialog-content ${className || &apos;&apos;}`}
      onPointerDown={(e) => {
        if (e.target === e.currentTarget) {
          handlePointerDownOutside(e.nativeEvent);
        }
      }}
    >
      {children}
    </div>
  );
};

DialogWithSlots.Content.displayName = &apos;DialogContent&apos;;

// Portal component for rendering outside DOM hierarchy
interface DialogPortalProps {
  children: ReactNode;
  container?: Element;
}

DialogWithSlots.Portal = function DialogPortal({ 
  children, 
  container 
}: DialogPortalProps) {
  const [mounted, setMounted] = useState(false);
  
  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) return null;

  return ReactDOM.createPortal(
    children,
    container || document.body
  );
};

DialogWithSlots.Portal.displayName = &apos;DialogPortal&apos;;

// Overlay component
interface DialogOverlayProps {
  className?: string;
  children?: ReactNode;
}

DialogWithSlots.Overlay = function DialogOverlay({ 
  className,
  children 
}: DialogOverlayProps) {
  return (
    <div className={`dialog-overlay ${className || &apos;&apos;}`}>
      {children}
    </div>
  );
};

DialogWithSlots.Overlay.displayName = &apos;DialogOverlay&apos;;

// Advanced usage with complete flexibility
function FlexibleDialog() {
  return (
    <DialogWithSlots modal onOpenChange={(open) => console.log(&apos;Dialog:&apos;, open)}>
      <DialogWithSlots.Trigger asChild>
        <button className=&quot;custom-trigger&quot;>Open Advanced Dialog</button>
      </DialogWithSlots.Trigger>
      
      <DialogWithSlots.Portal>
        <DialogWithSlots.Overlay className=&quot;custom-overlay&quot; />
        <DialogWithSlots.Content 
          className=&quot;custom-content&quot;
          onEscapeKeyDown={(e) => {
            console.log(&apos;Escape pressed&apos;);
            // Could prevent default to keep dialog open
          }}
          onPointerDownOutside={(e) => {
            console.log(&apos;Clicked outside&apos;);
            // Could prevent default to keep dialog open
          }}
        >
          <h2>Advanced Dialog</h2>
          <p>This dialog uses dynamic slots and advanced composition patterns.</p>
          
          <DialogWithSlots.Trigger asChild>
            <button>Close</button>
          </DialogWithSlots.Trigger>
        </DialogWithSlots.Content>
      </DialogWithSlots.Portal>
    </DialogWithSlots>
  );
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h2>Conclusion and Recommendations</h2>
<p>The Compound Pattern represents more than just a composition technique, it's a design philosophy that centers the developer experience and API flexibility. When fully mastered, it allows you to create components that are not only powerful but also delightful to use.</p>
<p><strong>For Type Safety:</strong></p>
<ul>
<li>Use generics to make your components reusable</li>
<li>Implement proper error boundaries and validation</li>
<li>Leverage TypeScript to create APIs that naturally guide correct usage</li>
</ul>
<p><strong>For Performance:</strong></p>
<ul>
<li>Split contexts when state and actions update at different frequencies</li>
<li>Use <code>useMemo</code> and <code>useCallback</code> strategically</li>
<li>Consider the impact of re-renders on complex component trees</li>
</ul>
<p><strong>For Architecture:</strong></p>
<ul>
<li>Apply the pattern to naturally related component groups</li>
<li>Maintain clear separation between state management and rendering logic</li>
<li>Design for composition, not configuration</li>
</ul>
<p><strong>For Extensibility:</strong></p>
<ul>
<li>Implement dynamic slots for maximum flexibility</li>
<li>Allow context overrides at intermediate levels</li>
<li>Create custom hooks for complex behaviors</li>
</ul>
<p>The compound pattern transforms how components feel to use. Not just functional, but intuitive. Not just flexible, but inevitable.</p>
<p>You'll know you've got it right when someone extends your component months later and the solution feels obvious, when complex UIs emerge from simple composition.
That's the mark of truly great component design.</p>
<h3>Additional Resources</h3>
<ul>
<li><a href="https://www.patterns.dev/react/compound-pattern/">React Compound Components Pattern</a></li>
<li><a href="https://github.com/kentcdodds/advanced-react-patterns">Advanced React Patterns</a></li>
<li><a href="https://react.dev/reference/react/createContext">React Context API Documentation</a></li>
<li><a href="https://www.radix-ui.com/primitives">Radix UI Primitives</a></li>
<li><a href="https://ui.shadcn.com/">ShadCN/UI Components</a></li>
</ul>
<p>Happy coding!</p>
</article><div class="my-8"></div></main><footer class="text-gray-600"><div class="max-w-6xl px-5 py-4 mx-auto flex items-center sm:flex-row flex-col"><a class="text-primary hover:underline underline-offset-2" aria-label="Email to paskfdev@gmail.com" title="Email to paskfdev@gmail.com" href="mailto:paskfdev@gmail.com">Pasquale Favella</a><p class="text-sm text-gray-500 sm:ml-4 sm:pl-4 sm:border-l-2 sm:border-gray-200 sm:py-2 sm:mt-0 mt-4">Â©<!-- -->2025<!-- --> â€¢ made with ðŸ’š</p><span class="inline-flex sm:ml-auto sm:mt-0 mt-4 justify-center items-center sm:justify-start gap-4"><a class="transition-all duration-300 hover:text-primary" href="https://github.com/Pasquale-Favella"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a class="transition-all duration-300 hover:text-primary" href="https://it.linkedin.com/in/pasquale-favella-1a3682187"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg></a></span></div><div class="fixed bottom-4 right-1 sm:bottom-10 sm:right-6 z-50 tooltip tooltip-left before:text-xs before:content-[attr(data-tip)]" data-tip="ask a question" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:Rbl6:" data-state="closed"><button class="btn btn-ghost btn-circle "><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="40" width="40" xmlns="http://www.w3.org/2000/svg"><path d="M16 8c0 3.866-3.582 7-8 7a9.06 9.06 0 0 1-2.347-.306c-.584.296-1.925.864-4.181 1.234-.2.032-.352-.176-.273-.362.354-.836.674-1.95.77-2.966C.744 11.37 0 9.76 0 8c0-3.866 3.582-7 8-7s8 3.134 8 7zM7.194 6.766a1.688 1.688 0 0 0-.227-.272 1.467 1.467 0 0 0-.469-.324l-.008-.004A1.785 1.785 0 0 0 5.734 6C4.776 6 4 6.746 4 7.667c0 .92.776 1.666 1.734 1.666.343 0 .662-.095.931-.26-.137.389-.39.804-.81 1.22a.405.405 0 0 0 .011.59c.173.16.447.155.614-.01 1.334-1.329 1.37-2.758.941-3.706a2.461 2.461 0 0 0-.227-.4zM11 9.073c-.136.389-.39.804-.81 1.22a.405.405 0 0 0 .012.59c.172.16.446.155.613-.01 1.334-1.329 1.37-2.758.942-3.706a2.466 2.466 0 0 0-.228-.4 1.686 1.686 0 0 0-.227-.273 1.466 1.466 0 0 0-.469-.324l-.008-.004A1.785 1.785 0 0 0 10.07 6c-.957 0-1.734.746-1.734 1.667 0 .92.777 1.666 1.734 1.666.343 0 .662-.095.931-.26z"></path></svg></button></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"content":"The Compound Pattern in React represents a powerful design approach that enables developers to create flexible, reusable components that work together seamlessly. This pattern addresses common challenges like prop drilling while promoting declarative code that's both readable and maintainable. This comprehensive guide explores the compound pattern through practical TypeScript examples, performance considerations, and advanced implementations.\n\n## Understanding the Compound Pattern\n\nThe Compound Pattern involves creating a parent component that manages state and behavior, while child components consume and display this state through a shared context. Compound components are a pattern in React, where several components are used together such that they share an implicit state that allows them to communicate with each other in the background. This pattern is particularly effective when multiple components need to work together to accomplish a shared task.\n\n### What Makes It Special?\n\nCompound components can be said to be a pattern that encloses the state and the behavior of a group of components but still gives the rendering control of its variable parts back to the external user. This approach provides several key advantages:\n\n- **Declarative API**: Components express what they do, not how they do it\n- **Flexible Composition**: Users can arrange child components in any order\n- **Implicit State Sharing**: Components communicate without explicit prop passing\n- **Enhanced Reusability**: Each component can be used independently when needed\n- **Type Safety**: TypeScript provides excellent support for this pattern\n\n## The Prop Drilling Problem\n\nBefore diving into the compound pattern, let's examine the traditional prop drilling approach and its limitations.\n\n### Traditional Prop Drilling Example\n\nConsider a simple menu component built with traditional prop drilling:\n\n```tsx\n// Traditional approach with prop drilling\ninterface MenuItem {\n  id: string;\n  label: string;\n}\n\ninterface MenuProps {\n  isOpen: boolean;\n  onToggle: () =\u003e void;\n  items: MenuItem[];\n  activeItem: string | null;\n  onItemClick: (id: string) =\u003e void;\n}\n\nfunction Menu({ isOpen, onToggle, items, activeItem, onItemClick }: MenuProps) {\n  return (\n    \u003cdiv className=\"menu\"\u003e\n      \u003cMenuButton isOpen={isOpen} onToggle={onToggle} /\u003e\n      \u003cMenuList \n        isOpen={isOpen} \n        items={items} \n        activeItem={activeItem} \n        onItemClick={onItemClick} \n      /\u003e\n    \u003c/div\u003e\n  );\n}\n\ninterface MenuButtonProps {\n  isOpen: boolean;\n  onToggle: () =\u003e void;\n}\n\nfunction MenuButton({ isOpen, onToggle }: MenuButtonProps) {\n  return (\n    \u003cbutton onClick={onToggle}\u003e\n      {isOpen ? 'Close' : 'Open'} Menu\n    \u003c/button\u003e\n  );\n}\n\ninterface MenuListProps {\n  isOpen: boolean;\n  items: MenuItem[];\n  activeItem: string | null;\n  onItemClick: (id: string) =\u003e void;\n}\n\nfunction MenuList({ isOpen, items, activeItem, onItemClick }: MenuListProps) {\n  if (!isOpen) return null;\n  \n  return (\n    \u003cul\u003e\n      {items.map(item =\u003e (\n        \u003cMenuItemComponent\n          key={item.id}\n          item={item}\n          isActive={item.id === activeItem}\n          onItemClick={onItemClick}\n        /\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n\ninterface MenuItemComponentProps {\n  item: MenuItem;\n  isActive: boolean;\n  onItemClick: (id: string) =\u003e void;\n}\n\nfunction MenuItemComponent({ item, isActive, onItemClick }: MenuItemComponentProps) {\n  return (\n    \u003cli \n      className={isActive ? 'active' : ''}\n      onClick={() =\u003e onItemClick(item.id)}\n    \u003e\n      {item.label}\n    \u003c/li\u003e\n  );\n}\n\n// Usage\nfunction App() {\n  const [isOpen, setIsOpen] = useState(false);\n  const [activeItem, setActiveItem] = useState\u003cstring | null\u003e(null);\n  const items: MenuItem[] = [\n    { id: '1', label: 'Home' },\n    { id: '2', label: 'About' },\n    { id: '3', label: 'Contact' }\n  ];\n\n  return (\n    \u003cMenu\n      isOpen={isOpen}\n      onToggle={() =\u003e setIsOpen(!isOpen)}\n      items={items}\n      activeItem={activeItem}\n      onItemClick={setActiveItem}\n    /\u003e\n  );\n}\n```\n\n### Problems with This Approach\n\nThe traditional approach presents several challenges:\n\n- **Tight Coupling**: Components are tightly bound to their parent's prop structure\n- **Verbose Props**: Every intermediate component must accept and pass props\n- **Limited Flexibility**: Changing the component structure requires updating multiple prop interfaces\n- **Poor Reusability**: Components become difficult to reuse in different contexts\n- **Complex Type Definitions**: Managing types across multiple levels becomes cumbersome\n\n## Compound Pattern Solution\n\nThe compound pattern elegantly solves these problems by using React Context to share state implicitly among related components.\n\n### Basic Compound Pattern Implementation\n\n```tsx\nimport React, { createContext, useContext, useState, ReactNode } from 'react';\n\n// Define the context type\ninterface MenuContextType {\n  isOpen: boolean;\n  setIsOpen: (isOpen: boolean) =\u003e void;\n  activeItem: string | null;\n  setActiveItem: (id: string | null) =\u003e void;\n  toggle: () =\u003e void;\n  selectItem: (id: string) =\u003e void;\n}\n\n// Create context for the compound component\nconst MenuContext = createContext\u003cMenuContextType | undefined\u003e(undefined);\n\n// Custom hook to access menu context\nfunction useMenuContext(): MenuContextType {\n  const context = useContext(MenuContext);\n  if (!context) {\n    throw new Error('Menu compound components must be used within Menu');\n  }\n  return context;\n}\n\n// Main Menu component interface\ninterface MenuProps {\n  children: ReactNode;\n}\n\n// Main Menu component that provides context\nfunction Menu({ children }: MenuProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [activeItem, setActiveItem] = useState\u003cstring | null\u003e(null);\n\n  const contextValue: MenuContextType = {\n    isOpen,\n    setIsOpen,\n    activeItem,\n    setActiveItem,\n    toggle: () =\u003e setIsOpen(!isOpen),\n    selectItem: (id: string) =\u003e setActiveItem(id)\n  };\n\n  return (\n    \u003cMenuContext.Provider value={contextValue}\u003e\n      \u003cdiv className=\"menu\"\u003e\n        {children}\n      \u003c/div\u003e\n    \u003c/MenuContext.Provider\u003e\n  );\n}\n\n// Compound components with proper typing\ninterface MenuButtonProps {\n  children?: ReactNode;\n}\n\nMenu.Button = function MenuButton({ children }: MenuButtonProps) {\n  const { isOpen, toggle } = useMenuContext();\n  \n  return (\n    \u003cbutton onClick={toggle}\u003e\n      {children || (isOpen ? 'Close Menu' : 'Open Menu')}\n    \u003c/button\u003e\n  );\n};\n\ninterface MenuListProps {\n  children: ReactNode;\n}\n\nMenu.List = function MenuList({ children }: MenuListProps) {\n  const { isOpen } = useMenuContext();\n  \n  if (!isOpen) return null;\n  \n  return \u003cul className=\"menu-list\"\u003e{children}\u003c/ul\u003e;\n};\n\ninterface MenuItemProps {\n  id: string;\n  children: ReactNode;\n}\n\nMenu.Item = function MenuItem({ id, children }: MenuItemProps) {\n  const { activeItem, selectItem } = useMenuContext();\n  const isActive = activeItem === id;\n  \n  return (\n    \u003cli \n      className={`menu-item ${isActive ? 'active' : ''}`}\n      onClick={() =\u003e selectItem(id)}\n    \u003e\n      {children}\n    \u003c/li\u003e\n  );\n};\n\n// Clean, declarative usage with full type safety\nfunction App() {\n  return (\n    \u003cMenu\u003e\n      \u003cMenu.Button\u003eToggle Navigation\u003c/Menu.Button\u003e\n      \u003cMenu.List\u003e\n        \u003cMenu.Item id=\"home\"\u003eHome\u003c/Menu.Item\u003e\n        \u003cMenu.Item id=\"about\"\u003eAbout\u003c/Menu.Item\u003e\n        \u003cMenu.Item id=\"services\"\u003eServices\u003c/Menu.Item\u003e\n        \u003cMenu.Item id=\"contact\"\u003eContact\u003c/Menu.Item\u003e\n      \u003c/Menu.List\u003e\n    \u003c/Menu\u003e\n  );\n}\n```\n\n### Key Improvements\n\nThe compound pattern version demonstrates several improvements:\n\n- **No Prop Drilling**: State is shared through context, eliminating prop passing\n- **Declarative Syntax**: The usage clearly expresses the component structure\n- **Flexible Composition**: Items can be arranged in any order or configuration\n- **Implicit Communication**: Components automatically stay in sync\n- **Type Safety**: Full TypeScript support with proper error handling\n\n## Advanced Compound Pattern Implementations\n\n### 1. Flexible Dialog Component\n\nHere's a more complex example showcasing the pattern's power with a dialog component:\n\n```tsx\nimport React, { \n  createContext, \n  useContext, \n  useState, \n  useEffect, \n  ReactNode, \n  MouseEvent,\n  KeyboardEvent\n} from 'react';\n\ninterface DialogContextType {\n  isOpen: boolean;\n  setIsOpen: (isOpen: boolean) =\u003e void;\n  loading: boolean;\n  setLoading: (loading: boolean) =\u003e void;\n  open: () =\u003e void;\n  close: () =\u003e void;\n  showLoading: () =\u003e void;\n  hideLoading: () =\u003e void;\n}\n\nconst DialogContext = createContext\u003cDialogContextType | undefined\u003e(undefined);\n\nfunction useDialogContext(): DialogContextType {\n  const context = useContext(DialogContext);\n  if (!context) {\n    throw new Error('Dialog compound components must be used within Dialog');\n  }\n  return context;\n}\n\ninterface DialogProps {\n  children: ReactNode;\n  onClose?: () =\u003e void;\n}\n\nfunction Dialog({ children, onClose }: DialogProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [loading, setLoading] = useState(false);\n\n  const contextValue: DialogContextType = {\n    isOpen,\n    setIsOpen,\n    loading,\n    setLoading,\n    open: () =\u003e setIsOpen(true),\n    close: () =\u003e {\n      setIsOpen(false);\n      onClose?.();\n    },\n    showLoading: () =\u003e setLoading(true),\n    hideLoading: () =\u003e setLoading(false)\n  };\n\n  // Handle escape key\n  useEffect(() =\u003e {\n    const handleEscape = (e: KeyboardEvent\u003cDocument\u003e) =\u003e {\n      if (e.key === 'Escape' \u0026\u0026 isOpen) {\n        contextValue.close();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape as any);\n      document.body.style.overflow = 'hidden';\n    }\n\n    return () =\u003e {\n      document.removeEventListener('keydown', handleEscape as any);\n      document.body.style.overflow = 'unset';\n    };\n  }, [isOpen, contextValue]);\n\n  return (\n    \u003cDialogContext.Provider value={contextValue}\u003e\n      {children}\n    \u003c/DialogContext.Provider\u003e\n  );\n}\n\ninterface DialogTriggerProps {\n  children: ReactNode;\n  asChild?: boolean;\n}\n\nDialog.Trigger = function DialogTrigger({ children, asChild = false }: DialogTriggerProps) {\n  const { open } = useDialogContext();\n  \n  if (asChild \u0026\u0026 React.isValidElement(children)) {\n    return React.cloneElement(children, { onClick: open });\n  }\n  \n  return \u003cbutton onClick={open}\u003e{children}\u003c/button\u003e;\n};\n\ninterface DialogContentProps {\n  children: ReactNode;\n  className?: string;\n}\n\nDialog.Content = function DialogContent({ children, className = '' }: DialogContentProps) {\n  const { isOpen, close } = useDialogContext();\n  \n  if (!isOpen) return null;\n  \n  const handleOverlayClick = (e: MouseEvent\u003cHTMLDivElement\u003e) =\u003e {\n    if (e.target === e.currentTarget) {\n      close();\n    }\n  };\n  \n  return (\n    \u003cdiv className={`dialog-overlay ${className}`} onClick={handleOverlayClick}\u003e\n      \u003cdiv className=\"dialog-content\"\u003e\n        {children}\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n};\n\ninterface DialogHeaderProps {\n  children: ReactNode;\n}\n\nDialog.Header = function DialogHeader({ children }: DialogHeaderProps) {\n  return \u003cdiv className=\"dialog-header\"\u003e{children}\u003c/div\u003e;\n};\n\ninterface DialogBodyProps {\n  children: ReactNode;\n}\n\nDialog.Body = function DialogBody({ children }: DialogBodyProps) {\n  const { loading } = useDialogContext();\n  \n  return (\n    \u003cdiv className=\"dialog-body\"\u003e\n      {loading \u0026\u0026 \u003cdiv className=\"loading-spinner\"\u003eLoading...\u003c/div\u003e}\n      {children}\n    \u003c/div\u003e\n  );\n};\n\ninterface DialogFooterProps {\n  children: ReactNode;\n}\n\nDialog.Footer = function DialogFooter({ children }: DialogFooterProps) {\n  return \u003cdiv className=\"dialog-footer\"\u003e{children}\u003c/div\u003e;\n};\n\ninterface DialogCloseProps {\n  children?: ReactNode;\n}\n\nDialog.Close = function DialogClose({ children }: DialogCloseProps) {\n  const { close } = useDialogContext();\n  \n  return (\n    \u003cbutton className=\"dialog-close\" onClick={close}\u003e\n      {children || 'Ã—'}\n    \u003c/button\u003e\n  );\n};\n\n// Usage example with full type safety\nfunction UserProfile() {\n  const handleSave = async (): Promise\u003cvoid\u003e =\u003e {\n    // Simulate API call\n    await new Promise(resolve =\u003e setTimeout(resolve, 2000));\n  };\n\n  return (\n    \u003cDialog onClose={() =\u003e console.log('Dialog closed')}\u003e\n      \u003cDialog.Trigger\u003e\n        \u003cbutton className=\"primary-btn\"\u003eEdit Profile\u003c/button\u003e\n      \u003c/Dialog.Trigger\u003e\n      \n      \u003cDialog.Content\u003e\n        \u003cDialog.Header\u003e\n          \u003ch2\u003eEdit Profile\u003c/h2\u003e\n          \u003cDialog.Close /\u003e\n        \u003c/Dialog.Header\u003e\n        \n        \u003cDialog.Body\u003e\n          \u003cform\u003e\n            \u003cinput type=\"text\" placeholder=\"Name\" /\u003e\n            \u003cinput type=\"email\" placeholder=\"Email\" /\u003e\n            \u003ctextarea placeholder=\"Bio\"\u003e\u003c/textarea\u003e\n          \u003c/form\u003e\n        \u003c/Dialog.Body\u003e\n        \n        \u003cDialog.Footer\u003e\n          \u003cDialog.Close\u003e\n            \u003cbutton className=\"secondary-btn\"\u003eCancel\u003c/button\u003e\n          \u003c/Dialog.Close\u003e\n          \u003cbutton className=\"primary-btn\" onClick={handleSave}\u003e\n            Save Changes\n          \u003c/button\u003e\n        \u003c/Dialog.Footer\u003e\n      \u003c/Dialog.Content\u003e\n    \u003c/Dialog\u003e\n  );\n}\n```\n\n### 2. Advanced Data Table Component\n\nFor more complex scenarios, here's a data table implementation that showcases the pattern's scalability:\n\n```tsx\nimport React, { \n  createContext, \n  useContext, \n  useState, \n  useMemo, \n  ReactNode \n} from 'react';\n\n// Generic type for table data\ninterface TableData {\n  id: string | number;\n  [key: string]: any;\n}\n\ntype SortDirection = 'asc' | 'desc';\n\ninterface TableContextType\u003cT extends TableData\u003e {\n  data: T[];\n  originalData: T[];\n  sortColumn: keyof T | null;\n  sortDirection: SortDirection;\n  filters: Record\u003cstring, string\u003e;\n  selectedRows: Set\u003cstring | number\u003e;\n  sort: (column: keyof T) =\u003e void;\n  filter: (column: string, value: string) =\u003e void;\n  selectRow: (id: string | number) =\u003e void;\n  selectAllRows: () =\u003e void;\n  clearSelection: () =\u003e void;\n}\n\nconst TableContext = createContext\u003cTableContextType\u003cany\u003e | undefined\u003e(undefined);\n\nfunction useTableContext\u003cT extends TableData\u003e(): TableContextType\u003cT\u003e {\n  const context = useContext(TableContext);\n  if (!context) {\n    throw new Error('Table compound components must be used within Table');\n  }\n  return context;\n}\n\ninterface TableProps\u003cT extends TableData\u003e {\n  data: T[];\n  children: ReactNode;\n}\n\nfunction Table\u003cT extends TableData\u003e({ data, children }: TableProps\u003cT\u003e) {\n  const [sortColumn, setSortColumn] = useState\u003ckeyof T | null\u003e(null);\n  const [sortDirection, setSortDirection] = useState\u003cSortDirection\u003e('asc');\n  const [filters, setFilters] = useState\u003cRecord\u003cstring, string\u003e\u003e({});\n  const [selectedRows, setSelectedRows] = useState\u003cSet\u003cstring | number\u003e\u003e(new Set());\n\n  const processedData = useMemo(() =\u003e {\n    let result = [...data];\n\n    // Apply filters\n    Object.entries(filters).forEach(([column, value]) =\u003e {\n      if (value) {\n        result = result.filter(row =\u003e \n          String(row[column]).toLowerCase().includes(value.toLowerCase())\n        );\n      }\n    });\n\n    // Apply sorting\n    if (sortColumn) {\n      result.sort((a, b) =\u003e {\n        const aVal = a[sortColumn];\n        const bVal = b[sortColumn];\n        const modifier = sortDirection === 'asc' ? 1 : -1;\n        \n        if (aVal \u003c bVal) return -1 * modifier;\n        if (aVal \u003e bVal) return 1 * modifier;\n        return 0;\n      });\n    }\n\n    return result;\n  }, [data, filters, sortColumn, sortDirection]);\n\n  const contextValue: TableContextType\u003cT\u003e = {\n    data: processedData,\n    originalData: data,\n    sortColumn,\n    sortDirection,\n    filters,\n    selectedRows,\n    sort: (column: keyof T) =\u003e {\n      if (sortColumn === column) {\n        setSortDirection(prev =\u003e prev === 'asc' ? 'desc' : 'asc');\n      } else {\n        setSortColumn(column);\n        setSortDirection('asc');\n      }\n    },\n    filter: (column: string, value: string) =\u003e {\n      setFilters(prev =\u003e ({ ...prev, [column]: value }));\n    },\n    selectRow: (id: string | number) =\u003e {\n      setSelectedRows(prev =\u003e {\n        const newSet = new Set(prev);\n        if (newSet.has(id)) {\n          newSet.delete(id);\n        } else {\n          newSet.add(id);\n        }\n        return newSet;\n      });\n    },\n    selectAllRows: () =\u003e {\n      setSelectedRows(new Set(processedData.map(row =\u003e row.id)));\n    },\n    clearSelection: () =\u003e {\n      setSelectedRows(new Set());\n    }\n  };\n\n  return (\n    \u003cTableContext.Provider value={contextValue}\u003e\n      \u003cdiv className=\"table-container\"\u003e\n        {children}\n      \u003c/div\u003e\n    \u003c/TableContext.Provider\u003e\n  );\n}\n\ninterface TableHeaderProps {\n  children: ReactNode;\n}\n\nTable.Header = function TableHeader({ children }: TableHeaderProps) {\n  return \u003cthead className=\"table-header\"\u003e{children}\u003c/thead\u003e;\n};\n\ninterface TableBodyProps {\n  children: ReactNode;\n}\n\nTable.Body = function TableBody({ children }: TableBodyProps) {\n  const { data } = useTableContext();\n  \n  return (\n    \u003ctbody className=\"table-body\"\u003e\n      {data.map((row, index) =\u003e (\n        \u003cTableRowProvider key={row.id} row={row} index={index}\u003e\n          {children}\n        \u003c/TableRowProvider\u003e\n      ))}\n    \u003c/tbody\u003e\n  );\n};\n\ninterface TableRowProps {\n  children: ReactNode;\n}\n\nTable.Row = function TableRow({ children }: TableRowProps) {\n  const { row, index } = useTableRowContext();\n  const { selectedRows } = useTableContext();\n  \n  return (\n    \u003ctr \n      className={`table-row ${selectedRows.has(row.id) ? 'selected' : ''}`}\n      data-index={index}\n    \u003e\n      {children}\n    \u003c/tr\u003e\n  );\n};\n\ninterface TableHeaderCellProps {\n  column?: string;\n  children: ReactNode;\n  sortable?: boolean;\n}\n\nTable.HeaderCell = function TableHeaderCell({ \n  column, \n  children, \n  sortable = false \n}: TableHeaderCellProps) {\n  const { sort, sortColumn, sortDirection } = useTableContext();\n  \n  const handleClick = () =\u003e {\n    if (sortable \u0026\u0026 column) {\n      sort(column);\n    }\n  };\n\n  return (\n    \u003cth \n      className={`table-header-cell ${sortable ? 'sortable' : ''}`}\n      onClick={handleClick}\n    \u003e\n      {children}\n      {sortable \u0026\u0026 sortColumn === column \u0026\u0026 (\n        \u003cspan className=\"sort-indicator\"\u003e\n          {sortDirection === 'asc' ? 'â†‘' : 'â†“'}\n        \u003c/span\u003e\n      )}\n    \u003c/th\u003e\n  );\n};\n\ninterface TableCellProps {\n  column?: string;\n  children?: ReactNode;\n}\n\nTable.Cell = function TableCell({ column, children }: TableCellProps) {\n  const { row } = useTableRowContext();\n  \n  return (\n    \u003ctd className=\"table-cell\"\u003e\n      {children || (column ? row[column] : '')}\n    \u003c/td\u003e\n  );\n};\n\nTable.SelectCell = function TableSelectCell() {\n  const { row } = useTableRowContext();\n  const { selectedRows, selectRow } = useTableContext();\n  \n  return (\n    \u003ctd className=\"table-select-cell\"\u003e\n      \u003cinput\n        type=\"checkbox\"\n        checked={selectedRows.has(row.id)}\n        onChange={() =\u003e selectRow(row.id)}\n      /\u003e\n    \u003c/td\u003e\n  );\n};\n\ninterface TableFilterProps {\n  column: string;\n  placeholder?: string;\n}\n\nTable.Filter = function TableFilter({ column, placeholder }: TableFilterProps) {\n  const { filters, filter } = useTableContext();\n  \n  return (\n    \u003cinput\n      type=\"text\"\n      placeholder={placeholder}\n      value={filters[column] || ''}\n      onChange={(e) =\u003e filter(column, e.target.value)}\n      className=\"table-filter\"\n    /\u003e\n  );\n};\n\n// Row context for accessing current row data\ninterface TableRowContextType\u003cT extends TableData = TableData\u003e {\n  row: T;\n  index: number;\n}\n\nconst TableRowContext = createContext\u003cTableRowContextType | undefined\u003e(undefined);\n\ninterface TableRowProviderProps\u003cT extends TableData\u003e {\n  row: T;\n  index: number;\n  children: ReactNode;\n}\n\nfunction TableRowProvider\u003cT extends TableData\u003e({ \n  row, \n  index, \n  children \n}: TableRowProviderProps\u003cT\u003e) {\n  return (\n    \u003cTableRowContext.Provider value={{ row, index }}\u003e\n      {children}\n    \u003c/TableRowContext.Provider\u003e\n  );\n}\n\nfunction useTableRowContext\u003cT extends TableData = TableData\u003e(): TableRowContextType\u003cT\u003e {\n  const context = useContext(TableRowContext);\n  if (!context) {\n    throw new Error('Table row components must be used within Table.Body');\n  }\n  return context as TableRowContextType\u003cT\u003e;\n}\n\n// Usage example with proper typing\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  role: 'Admin' | 'User';\n}\n\nfunction UsersTable() {\n  const users: User[] = [\n    { id: '1', name: 'John Doe', email: 'john@example.com', role: 'Admin' },\n    { id: '2', name: 'Jane Smith', email: 'jane@example.com', role: 'User' },\n    { id: '3', name: 'Bob Johnson', email: 'bob@example.com', role: 'User' }\n  ];\n\n  return (\n    \u003cdiv\u003e\n      \u003cdiv className=\"table-controls\"\u003e\n        \u003cTable.Filter column=\"name\" placeholder=\"Filter by name...\" /\u003e\n        \u003cTable.Filter column=\"email\" placeholder=\"Filter by email...\" /\u003e\n      \u003c/div\u003e\n      \n      \u003ctable\u003e\n        \u003cTable\u003cUser\u003e data={users}\u003e\n          \u003cTable.Header\u003e\n            \u003ctr\u003e\n              \u003cTable.HeaderCell\u003e\n                \u003cinput type=\"checkbox\" /\u003e\n              \u003c/Table.HeaderCell\u003e\n              \u003cTable.HeaderCell column=\"name\" sortable\u003e\n                Name\n              \u003c/Table.HeaderCell\u003e\n              \u003cTable.HeaderCell column=\"email\" sortable\u003e\n                Email\n              \u003c/Table.HeaderCell\u003e\n              \u003cTable.HeaderCell column=\"role\"\u003e\n                Role\n              \u003c/Table.HeaderCell\u003e\n            \u003c/tr\u003e\n          \u003c/Table.Header\u003e\n          \n          \u003cTable.Body\u003e\n            \u003cTable.Row\u003e\n              \u003cTable.SelectCell /\u003e\n              \u003cTable.Cell column=\"name\" /\u003e\n              \u003cTable.Cell column=\"email\" /\u003e\n              \u003cTable.Cell column=\"role\"\u003e\n                \u003cspan className=\"role-badge\"\u003e\n                  {/* Custom rendering with full type safety */}\n                \u003c/span\u003e\n              \u003c/Table.Cell\u003e\n            \u003c/Table.Row\u003e\n          \u003c/Table.Body\u003e\n        \u003c/Table\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n## Performance Considerations\n\nWhile the compound pattern offers excellent developer experience, it's important to consider performance implications:\n\n### Context Performance Optimization\n\n```tsx\nimport React, { \n  createContext, \n  useContext, \n  useMemo, \n  useCallback, \n  useState,\n  ReactNode \n} from 'react';\n\ninterface MenuState {\n  isOpen: boolean;\n  activeItem: string | null;\n}\n\ninterface MenuActions {\n  toggle: () =\u003e void;\n  selectItem: (id: string) =\u003e void;\n}\n\nconst MenuStateContext = createContext\u003cMenuState | undefined\u003e(undefined);\nconst MenuActionsContext = createContext\u003cMenuActions | undefined\u003e(undefined);\n\ninterface OptimizedMenuProps {\n  children: ReactNode;\n}\n\nfunction OptimizedMenu({ children }: OptimizedMenuProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [activeItem, setActiveItem] = useState\u003cstring | null\u003e(null);\n\n  // Separate state context (changes frequently)\n  const stateContextValue = useMemo((): MenuState =\u003e ({\n    isOpen,\n    activeItem\n  }), [isOpen, activeItem]);\n\n  // Separate actions context (stable)\n  const actionsContextValue = useMemo((): MenuActions =\u003e ({\n    toggle: () =\u003e setIsOpen(prev =\u003e !prev),\n    selectItem: (id: string) =\u003e setActiveItem(id)\n  }), []);\n\n  return (\n    \u003cMenuStateContext.Provider value={stateContextValue}\u003e\n      \u003cMenuActionsContext.Provider value={actionsContextValue}\u003e\n        \u003cdiv className=\"menu\"\u003e{children}\u003c/div\u003e\n      \u003c/MenuActionsContext.Provider\u003e\n    \u003c/MenuStateContext.Provider\u003e\n  );\n}\n\n// Separate hooks for better performance\nfunction useMenuState(): MenuState {\n  const context = useContext(MenuStateContext);\n  if (!context) {\n    throw new Error('useMenuState must be used within OptimizedMenu');\n  }\n  return context;\n}\n\nfunction useMenuActions(): MenuActions {\n  const context = useContext(MenuActionsContext);\n  if (!context) {\n    throw new Error('useMenuActions must be used within OptimizedMenu');\n  }\n  return context;\n}\n```\n\n### Best Practices for Performance\n\n1. **Split Contexts**: Separate frequently changing state from stable actions\n2. **Memoize Context Values**: Use `useMemo` to prevent unnecessary re-renders\n3. **Optimize Child Components**: Use `React.memo` for compound components when appropriate\n4. **Lazy Evaluation**: Only compute expensive values when needed\n5. **Proper TypeScript**: Use generics and proper typing for better performance and DX\n\n## When to Use the Compound Pattern\n\nThe compound pattern shines in specific scenarios:\n\n### Ideal Use Cases\n\n- **Related Component Groups**: When components naturally work together (tabs, accordion, dropdown)\n- **Complex State Management**: When multiple components need to share and synchronize state\n- **Flexible APIs**: When users need control over component arrangement and styling\n- **Design Systems**: When building reusable component libraries with TypeScript\n- **Library Development**: When creating components that need to be highly composable\n\n### When to Avoid\n\n- **Simple Components**: When prop drilling involves only one or two levels\n- **Performance-Critical Paths**: When context updates would cause expensive re-renders\n- **Unrelated Components**: When components don't naturally belong together\n- **Over-Engineering**: When simpler patterns would suffice\n\n## Comparison with Other Patterns\n\n### Compound Pattern vs. Render Props\n\n```tsx\n// Render Props approach\ninterface MenuRenderProps {\n  isOpen: boolean;\n  setIsOpen: (isOpen: boolean) =\u003e void;\n  toggle: () =\u003e void;\n}\n\ninterface MenuWithRenderProps {\n  children: (props: MenuRenderProps) =\u003e ReactNode;\n}\n\nfunction MenuWithRenderProps({ children }: MenuWithRenderProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  return children({ \n    isOpen, \n    setIsOpen, \n    toggle: () =\u003e setIsOpen(!isOpen) \n  });\n}\n\n// Usage - less declarative\n\u003cMenuWithRenderProps\u003e\n  {({ isOpen, toggle }) =\u003e (\n    \u003cdiv\u003e\n      \u003cbutton onClick={toggle}\u003eToggle\u003c/button\u003e\n      {isOpen \u0026\u0026 \u003cul\u003e...\u003c/ul\u003e}\n    \u003c/div\u003e\n  )}\n\u003c/MenuWithRenderProps\u003e\n\n// Compound Pattern is more declarative and readable\n\u003cMenu\u003e\n  \u003cMenu.Button\u003eToggle\u003c/Menu.Button\u003e\n  \u003cMenu.List\u003e...\u003c/Menu.List\u003e\n\u003c/Menu\u003e\n```\n\n### Compound Pattern vs. HOCs\n\nThe compound pattern offers better composition and avoids the wrapper hell often associated with Higher-Order Components while providing excellent TypeScript support and better inference.\n# **Extending the pattern: beyond composition**\n\nOnce you've grasped the power of the Compound Pattern, it's time to push beyond. Here are some advanced techniques that can transform your components from simple building blocks into true user interface ecosystems.\n\n## Auto-Detection of Child Components\n\nSometimes exposing a declarative API isn't enough, we also need to be smart about how our components behave based on their structure. Using `React.Children` and traversal functions, we can create components that automatically adapt to their content.\n\n```tsx\nimport React, { ReactNode, ReactElement, Children, isValidElement } from 'react';\n\ninterface TabsProps {\n  children: ReactNode;\n  defaultValue?: string;\n}\n\nfunction Tabs({ children, defaultValue }: TabsProps) {\n  const [activeTab, setActiveTab] = useState\u003cstring\u003e(() =\u003e {\n    // Auto-detect first tab if no default provided\n    if (defaultValue) return defaultValue;\n    \n    const tabList = Children.toArray(children).find(\n      (child): child is ReactElement =\u003e \n        isValidElement(child) \u0026\u0026 child.type === Tabs.List\n    );\n    \n    if (tabList) {\n      const firstTrigger = Children.toArray(tabList.props.children).find(\n        (child): child is ReactElement =\u003e \n          isValidElement(child) \u0026\u0026 child.type === Tabs.Trigger\n      );\n      \n      return firstTrigger?.props.value || '';\n    }\n    \n    return '';\n  });\n\n  const contextValue = {\n    activeTab,\n    setActiveTab,\n    // Auto-detect available tabs\n    availableTabs: useMemo(() =\u003e {\n      const tabs: string[] = [];\n      \n      Children.forEach(children, (child) =\u003e {\n        if (isValidElement(child) \u0026\u0026 child.type === Tabs.Content) {\n          tabs.push(child.props.value);\n        }\n      });\n      \n      return tabs;\n    }, [children])\n  };\n\n  return (\n    \u003cTabsContext.Provider value={contextValue}\u003e\n      \u003cdiv className=\"tabs\"\u003e{children}\u003c/div\u003e\n    \u003c/TabsContext.Provider\u003e\n  );\n}\n\nTabs.List = function TabsList({ children }: { children: ReactNode }) {\n  const { availableTabs } = useTabsContext();\n  \n  // Auto-filter only valid triggers\n  const validTriggers = Children.toArray(children).filter(\n    (child): child is ReactElement =\u003e \n      isValidElement(child) \u0026\u0026 \n      child.type === Tabs.Trigger \u0026\u0026\n      availableTabs.includes(child.props.value)\n  );\n\n  return (\n    \u003cdiv className=\"tabs-list\" role=\"tablist\"\u003e\n      {validTriggers}\n    \u003c/div\u003e\n  );\n};\n\nTabs.Trigger = function TabsTrigger({ \n  value,\n  children \n}: { \n  value: string; \n  children: ReactNode \n}) {\n  const { activeTab, setActiveTab } = useTabsContext();\n  \n  return (\n    \u003cbutton\n      role=\"tab\"\n      aria-selected={activeTab === value}\n      className={`tabs-trigger ${activeTab === value ? 'active' : ''}`}\n      onClick={() =\u003e setActiveTab(value)}\n    \u003e\n      {children}\n    \u003c/button\u003e\n  );\n};\n\nTabs.Content = function TabsContent({ \n  value, \n  children \n}: { \n  value: string; \n  children: ReactNode \n}) {\n  const { activeTab } = useTabsContext();\n  \n  if (activeTab !== value) return null;\n  \n  return (\n    \u003cdiv role=\"tabpanel\" className=\"tabs-content\"\u003e\n      {children}\n    \u003c/div\u003e\n  );\n};\n\n// Usage with auto-detection\nfunction SmartTabs() {\n  return (\n    \u003cTabs defaultValue=\"overview\"\u003e\n      \u003cTabs.List\u003e\n        \u003cTabs.Trigger value=\"overview\"\u003eOverview\u003c/Tabs.Trigger\u003e\n        \u003cTabs.Trigger value=\"settings\"\u003eSettings\u003c/Tabs.Trigger\u003e\n        \u003cTabs.Trigger value=\"invalid\"\u003eInvalid\u003c/Tabs.Trigger\u003e {/* Automatically filtered */}\n      \u003c/Tabs.List\u003e\n      \n      \u003cTabs.Content value=\"overview\"\u003e\n        \u003ch2\u003eOverview Content\u003c/h2\u003e\n      \u003c/Tabs.Content\u003e\n      \n      \u003cTabs.Content value=\"settings\"\u003e\n        \u003ch2\u003eSettings Content\u003c/h2\u003e\n      \u003c/Tabs.Content\u003e\n      \n      {/* The \"invalid\" trigger has no corresponding content */}\n    \u003c/Tabs\u003e\n  );\n}\n```\n\n## Context Overrides at Intermediate Levels\n\nOne of the most powerful patterns is the ability to override compound component behavior at intermediate levels. This allows you to create nested components that can modify parent behavior without breaking the communication chain.\n\n```tsx\ninterface NestedMenuContextType extends MenuContextType {\n  level: number;\n  parentContext?: MenuContextType;\n}\n\nconst NestedMenuContext = createContext\u003cNestedMenuContextType | undefined\u003e(undefined);\n\ninterface SubmenuProps {\n  children: ReactNode;\n  trigger: ReactNode;\n  disabled?: boolean;\n}\n\nfunction Submenu({ children, trigger, disabled = false }: SubmenuProps) {\n  const parentContext = useMenuContext();\n  const [isOpen, setIsOpen] = useState(false);\n  \n  // Override specific behaviors while preserving parent context\n  const nestedContextValue: NestedMenuContextType = {\n    ...parentContext,\n    level: (parentContext as any).level + 1 || 1,\n    parentContext,\n    isOpen,\n    setIsOpen,\n    toggle: () =\u003e !disabled \u0026\u0026 setIsOpen(!isOpen),\n    // Preserve parent's active item logic\n    selectItem: (id: string) =\u003e {\n      parentContext.selectItem(id);\n      setIsOpen(false); // Close submenu when item is selected\n    }\n  };\n\n  return (\n    \u003cNestedMenuContext.Provider value={nestedContextValue}\u003e\n      \u003cdiv className={`submenu level-${nestedContextValue.level}`}\u003e\n        \u003cdiv \n          className={`submenu-trigger ${disabled ? 'disabled' : ''}`}\n          onClick={nestedContextValue.toggle}\n        \u003e\n          {trigger}\n        \u003c/div\u003e\n        \n        {isOpen \u0026\u0026 (\n          \u003cdiv className=\"submenu-content\"\u003e\n            {children}\n          \u003c/div\u003e\n        )}\n      \u003c/div\u003e\n    \u003c/NestedMenuContext.Provider\u003e\n  );\n}\n\n// Hook that works with both normal and nested context\nfunction useMenuOrNestedContext(): MenuContextType | NestedMenuContextType {\n  const nestedContext = useContext(NestedMenuContext);\n  const menuContext = useMenuContext();\n  \n  return nestedContext || menuContext;\n}\n\n// Usage with nested overrides\nfunction AdvancedMenu() {\n  return (\n    \u003cMenu\u003e\n      \u003cMenu.Button\u003eMain Menu\u003c/Menu.Button\u003e\n      \u003cMenu.List\u003e\n        \u003cMenu.Item id=\"home\"\u003eHome\u003c/Menu.Item\u003e\n        \n        \u003cSubmenu trigger={\u003cspan\u003eProducts â–¶\u003c/span\u003e}\u003e\n          \u003cMenu.Item id=\"product-1\"\u003eProduct 1\u003c/Menu.Item\u003e\n          \u003cMenu.Item id=\"product-2\"\u003eProduct 2\u003c/Menu.Item\u003e\n          \n          \u003cSubmenu trigger={\u003cspan\u003eCategories â–¶\u003c/span\u003e}\u003e\n            \u003cMenu.Item id=\"cat-1\"\u003eCategory 1\u003c/Menu.Item\u003e\n            \u003cMenu.Item id=\"cat-2\"\u003eCategory 2\u003c/Menu.Item\u003e\n          \u003c/Submenu\u003e\n        \u003c/Submenu\u003e\n        \n        \u003cMenu.Item id=\"about\"\u003eAbout\u003c/Menu.Item\u003e\n      \u003c/Menu.List\u003e\n    \u003c/Menu\u003e\n  );\n}\n```\n\n## Dynamic Slots: The ShadCN/Radix Pattern\n\nThe true power of the compound pattern emerges when we implement dynamic slots, allowing components to adapt and reorganize based on content. This is the secret behind the flexibility of libraries like Radix UI and ShadCN.\n\n```tsx\ninterface SlotProps {\n  children?: ReactNode;\n  asChild?: boolean;\n}\n\n// Primitive Slot component inspired by Radix\nfunction Slot({ children, asChild = false, ...props }: SlotProps \u0026 any) {\n  if (asChild \u0026\u0026 React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...props,\n      ...children.props,\n      className: `${props.className || ''} ${children.props.className || ''}`.trim()\n    });\n  }\n  \n  return React.createElement('div', props, children);\n}\n\n// Advanced Dialog with dynamic slots\ninterface DialogWithSlotsProps {\n  children: ReactNode;\n  modal?: boolean;\n  onOpenChange?: (open: boolean) =\u003e void;\n}\n\nfunction DialogWithSlots({ children, modal = true, onOpenChange }: DialogWithSlotsProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  const handleOpenChange = (open: boolean) =\u003e {\n    setIsOpen(open);\n    onOpenChange?.(open);\n  };\n\n  // Detect and organize slots automatically\n  const slots = useMemo(() =\u003e {\n    const result: {\n      trigger?: ReactElement;\n      content?: ReactElement;\n      overlay?: ReactElement;\n      portal?: ReactElement;\n    } = {};\n    \n    Children.forEach(children, (child) =\u003e {\n      if (isValidElement(child)) {\n        const displayName = (child.type as any).displayName;\n        \n        switch (displayName) {\n          case 'DialogTrigger':\n            result.trigger = child;\n            break;\n          case 'DialogContent':\n            result.content = child;\n            break;\n          case 'DialogOverlay':\n            result.overlay = child;\n            break;\n          case 'DialogPortal':\n            result.portal = child;\n            break;\n        }\n      }\n    });\n    \n    return result;\n  }, [children]);\n\n  const contextValue = {\n    isOpen,\n    onOpenChange: handleOpenChange,\n    modal,\n    slots\n  };\n\n  return (\n    \u003cDialogContext.Provider value={contextValue}\u003e\n      {slots.trigger}\n      {isOpen \u0026\u0026 (\n        modal ? (\n          \u003cDialogPortal\u003e\n            {slots.overlay}\n            {slots.content}\n          \u003c/DialogPortal\u003e\n        ) : (\n          \u003c\u003e\n            {slots.overlay}\n            {slots.content}\n          \u003c/\u003e\n        )\n      )}\n    \u003c/DialogContext.Provider\u003e\n  );\n}\n\n// Dynamic slot components\ninterface DialogTriggerProps {\n  children: ReactNode;\n  asChild?: boolean;\n}\n\nDialogWithSlots.Trigger = function DialogTrigger({ \n  children, \n  asChild = false \n}: DialogTriggerProps) {\n  const { onOpenChange } = useDialogContext();\n  \n  const handleClick = () =\u003e onOpenChange(true);\n  \n  return (\n    \u003cSlot asChild={asChild} onClick={handleClick}\u003e\n      {children}\n    \u003c/Slot\u003e\n  );\n};\n\nDialogWithSlots.Trigger.displayName = 'DialogTrigger';\n\ninterface DialogContentProps {\n  children: ReactNode;\n  className?: string;\n  onPointerDownOutside?: (event: Event) =\u003e void;\n  onEscapeKeyDown?: (event: KeyboardEvent) =\u003e void;\n}\n\nDialogWithSlots.Content = function DialogContent({\n  children,\n  className,\n  onPointerDownOutside,\n  onEscapeKeyDown\n}: DialogContentProps) {\n  const { isOpen, onOpenChange, modal } = useDialogContext();\n  \n  useEffect(() =\u003e {\n    const handleEscape = (e: KeyboardEvent) =\u003e {\n      if (e.key === 'Escape') {\n        onEscapeKeyDown?.(e);\n        if (!e.defaultPrevented) {\n          onOpenChange(false);\n        }\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape);\n    }\n\n    return () =\u003e {\n      document.removeEventListener('keydown', handleEscape);\n    };\n  }, [isOpen, onOpenChange, onEscapeKeyDown]);\n\n  const handlePointerDownOutside = (e: Event) =\u003e {\n    onPointerDownOutside?.(e);\n    if (!e.defaultPrevented \u0026\u0026 modal) {\n      onOpenChange(false);\n    }\n  };\n\n  return (\n    \u003cdiv\n      className={`dialog-content ${className || ''}`}\n      onPointerDown={(e) =\u003e {\n        if (e.target === e.currentTarget) {\n          handlePointerDownOutside(e.nativeEvent);\n        }\n      }}\n    \u003e\n      {children}\n    \u003c/div\u003e\n  );\n};\n\nDialogWithSlots.Content.displayName = 'DialogContent';\n\n// Portal component for rendering outside DOM hierarchy\ninterface DialogPortalProps {\n  children: ReactNode;\n  container?: Element;\n}\n\nDialogWithSlots.Portal = function DialogPortal({ \n  children, \n  container \n}: DialogPortalProps) {\n  const [mounted, setMounted] = useState(false);\n  \n  useEffect(() =\u003e {\n    setMounted(true);\n  }, []);\n\n  if (!mounted) return null;\n\n  return ReactDOM.createPortal(\n    children,\n    container || document.body\n  );\n};\n\nDialogWithSlots.Portal.displayName = 'DialogPortal';\n\n// Overlay component\ninterface DialogOverlayProps {\n  className?: string;\n  children?: ReactNode;\n}\n\nDialogWithSlots.Overlay = function DialogOverlay({ \n  className,\n  children \n}: DialogOverlayProps) {\n  return (\n    \u003cdiv className={`dialog-overlay ${className || ''}`}\u003e\n      {children}\n    \u003c/div\u003e\n  );\n};\n\nDialogWithSlots.Overlay.displayName = 'DialogOverlay';\n\n// Advanced usage with complete flexibility\nfunction FlexibleDialog() {\n  return (\n    \u003cDialogWithSlots modal onOpenChange={(open) =\u003e console.log('Dialog:', open)}\u003e\n      \u003cDialogWithSlots.Trigger asChild\u003e\n        \u003cbutton className=\"custom-trigger\"\u003eOpen Advanced Dialog\u003c/button\u003e\n      \u003c/DialogWithSlots.Trigger\u003e\n      \n      \u003cDialogWithSlots.Portal\u003e\n        \u003cDialogWithSlots.Overlay className=\"custom-overlay\" /\u003e\n        \u003cDialogWithSlots.Content \n          className=\"custom-content\"\n          onEscapeKeyDown={(e) =\u003e {\n            console.log('Escape pressed');\n            // Could prevent default to keep dialog open\n          }}\n          onPointerDownOutside={(e) =\u003e {\n            console.log('Clicked outside');\n            // Could prevent default to keep dialog open\n          }}\n        \u003e\n          \u003ch2\u003eAdvanced Dialog\u003c/h2\u003e\n          \u003cp\u003eThis dialog uses dynamic slots and advanced composition patterns.\u003c/p\u003e\n          \n          \u003cDialogWithSlots.Trigger asChild\u003e\n            \u003cbutton\u003eClose\u003c/button\u003e\n          \u003c/DialogWithSlots.Trigger\u003e\n        \u003c/DialogWithSlots.Content\u003e\n      \u003c/DialogWithSlots.Portal\u003e\n    \u003c/DialogWithSlots\u003e\n  );\n}\n```\n\n\n## Conclusion and Recommendations\n\nThe Compound Pattern represents more than just a composition technique, it's a design philosophy that centers the developer experience and API flexibility. When fully mastered, it allows you to create components that are not only powerful but also delightful to use.\n\n**For Type Safety:**\n- Use generics to make your components reusable\n- Implement proper error boundaries and validation\n- Leverage TypeScript to create APIs that naturally guide correct usage\n\n**For Performance:**\n- Split contexts when state and actions update at different frequencies\n- Use `useMemo` and `useCallback` strategically\n- Consider the impact of re-renders on complex component trees\n\n**For Architecture:**\n- Apply the pattern to naturally related component groups\n- Maintain clear separation between state management and rendering logic\n- Design for composition, not configuration\n\n**For Extensibility:**\n- Implement dynamic slots for maximum flexibility\n- Allow context overrides at intermediate levels\n- Create custom hooks for complex behaviors\n\nThe compound pattern transforms how components feel to use. Not just functional, but intuitive. Not just flexible, but inevitable.\n\nYou'll know you've got it right when someone extends your component months later and the solution feels obvious, when complex UIs emerge from simple composition.\nThat's the mark of truly great component design.\n\n### Additional Resources\n\n- [React Compound Components Pattern](https://www.patterns.dev/react/compound-pattern/)\n- [Advanced React Patterns](https://github.com/kentcdodds/advanced-react-patterns)\n- [React Context API Documentation](https://react.dev/reference/react/createContext)\n- [Radix UI Primitives](https://www.radix-ui.com/primitives)\n- [ShadCN/UI Components](https://ui.shadcn.com/)\n\nHappy coding!","slug":"28","title":"Mastering the Compound Pattern in React: Building Declarative and Flexible Components with TypeScript","meta_description":"The Compound Pattern in React represents a powerful design approach that enables developers to create flexible, reusable components that work together seamlessly","tags":["React","Next JS"]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"28"},"buildId":"dODZe4XLr2VvEciUuuaXU","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>