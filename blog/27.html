<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:url" content="https://pasquale-favella.github.io/"/><meta property="og:image" content="https://pasquale-favella.github.io/og-image.png"/><meta property="og:locale" content="en_US"/><meta property="og:site_name" content="Pasquale Favella blogfolio"/><meta name="google-site-verification" content="BF08ecEW9P2w_w4mwWTU2LxdORMDiIO3XUeZLW7UC4o"/><link rel="icon" href="https://pasquale-favella.github.io/favicon.ico"/><title>Pasquale Favella | Next.js Server Actions for Data Fetching: Performance Issues and Solutions</title><meta name="robots" content="index,follow"/><meta name="description" content="Next"/><meta property="og:title" content="Pasquale Favella | Next.js Server Actions for Data Fetching: Performance Issues and Solutions"/><meta property="og:description" content="Next"/><meta property="og:type" content="article"/><meta property="article:tag" content="React"/><meta property="article:tag" content="Next JS"/><meta name="next-head-count" content="16"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/3b7b549399615939.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/3b7b549399615939.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f3ec281a508fd4c5.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-314c182fa7e2bf37.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-a767d6d8830842fe.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-d4b37b118c0a48d3.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/5d416436-a14b58fb3359beff.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/29107295-4cc022cea922dbb4.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/738-d0de949e184775d4.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-d13018a4707e2059.js" defer="" crossorigin=""></script><script src="/_next/static/RHGHCub-nt6FBtRy5YMos/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/RHGHCub-nt6FBtRy5YMos/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,n='data-theme',s='setAttribute';var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';d[s](n,'dark')}else{d.style.colorScheme = 'light';d[s](n,'light')}}else if(e){d[s](n,e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><header class="fixed top-0 left-0 right-0 z-40 shadow-sm backdrop-blur-[10px] bg-base-100/80 saturate-100"><div class="mx-auto flex h-[60px] max-w-6xl items-center justify-between px-8"><div><a aria-label="Pasquale&#x27;s website" href="/"><div class="flex items-center justify-between text-xl font-semibold">~ P: /blog<div class="Typewriter" data-testid="typewriter-wrapper"></div></div></a></div><div class="flex items-center gap-2"><div class="tooltip tooltip-bottom before:text-xs before:content-[attr(data-tip)]" data-tip="commands"><button class="btn btn-ghost btn-circle btn-sm"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path></svg></button></div><div class="tooltip tooltip-bottom before:text-xs before:content-[attr(data-tip)]" data-tip="change theme"><label class="swap swap-rotate btn btn-ghost btn-circle btn-sm"><input id="theme-toggle" type="checkbox"/><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="swap-on" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"></path></svg><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="swap-off" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M10 6C10 10.4183 13.5817 14 18 14C19.4386 14 20.7885 13.6203 21.9549 12.9556C21.4738 18.0302 17.2005 22 12 22C6.47715 22 2 17.5228 2 12C2 6.79948 5.9698 2.52616 11.0444 2.04507C10.3797 3.21152 10 4.56142 10 6ZM4 12C4 16.4183 7.58172 20 12 20C14.9654 20 17.5757 18.3788 18.9571 15.9546C18.6407 15.9848 18.3214 16 18 16C12.4772 16 8 11.5228 8 6C8 5.67863 8.01524 5.35933 8.04536 5.04293C5.62119 6.42426 4 9.03458 4 12ZM18.1642 2.29104L19 2.5V3.5L18.1642 3.70896C17.4476 3.8881 16.8881 4.4476 16.709 5.16417L16.5 6H15.5L15.291 5.16417C15.1119 4.4476 14.5524 3.8881 13.8358 3.70896L13 3.5V2.5L13.8358 2.29104C14.5524 2.1119 15.1119 1.5524 15.291 0.835829L15.5 0H16.5L16.709 0.835829C16.8881 1.5524 17.4476 2.1119 18.1642 2.29104ZM23.1642 7.29104L24 7.5V8.5L23.1642 8.70896C22.4476 8.8881 21.8881 9.4476 21.709 10.1642L21.5 11H20.5L20.291 10.1642C20.1119 9.4476 19.5524 8.8881 18.8358 8.70896L18 8.5V7.5L18.8358 7.29104C19.5524 7.1119 20.1119 6.5524 20.291 5.83583L20.5 5H21.5L21.709 5.83583C21.8881 6.5524 22.4476 7.1119 23.1642 7.29104Z"></path></svg></label></div></div></div></header><main class="relative mx-auto min-h-layout max-w-6xl px-8 pt-20 mb-2"><a class="group fixed top-24 hidden items-center justify-center text-sm font-medium xl:inline-flex" href="/blog"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="h-4 w-4 transition duration-200 group-hover:translate-x-1" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" d="M0 0h24v24H0V0z"></path><path d="M15.41 16.59 10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"></path></svg><span>See all Posts</span></a><div class="prose md:prose-lg lg:prose-xl mx-auto  mb-3 lg:mb-5"><h1 class="text-4xl font-extrabold leading-tight md:text-5xl !mb-4">Next.js Server Actions for Data Fetching: Performance Issues and Solutions</h1><div class="flex gap-2"><a class="badge badge-lg border-base-content hover:border-accent-content hover:opacity-80 no-underline py-4" href="/blog?tag=React"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 20 20" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M9.243 3.03a1 1 0 01.727 1.213L9.53 6h2.94l.56-2.243a1 1 0 111.94.486L14.53 6H17a1 1 0 110 2h-2.97l-1 4H15a1 1 0 110 2h-2.47l-.56 2.242a1 1 0 11-1.94-.485L10.47 14H7.53l-.56 2.242a1 1 0 11-1.94-.485L5.47 14H3a1 1 0 110-2h2.97l1-4H5a1 1 0 110-2h2.47l.56-2.243a1 1 0 011.213-.727zM9.03 8l-1 4h2.938l1-4H9.031z" clip-rule="evenodd"></path></svg>React</a><a class="badge badge-lg border-base-content hover:border-accent-content hover:opacity-80 no-underline py-4" href="/blog?tag=Next+JS"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 20 20" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M9.243 3.03a1 1 0 01.727 1.213L9.53 6h2.94l.56-2.243a1 1 0 111.94.486L14.53 6H17a1 1 0 110 2h-2.97l-1 4H15a1 1 0 110 2h-2.47l-.56 2.242a1 1 0 11-1.94-.485L10.47 14H7.53l-.56 2.242a1 1 0 11-1.94-.485L5.47 14H3a1 1 0 110-2h2.97l1-4H5a1 1 0 110-2h2.47l.56-2.243a1 1 0 011.213-.727zM9.03 8l-1 4h2.938l1-4H9.031z" clip-rule="evenodd"></path></svg>Next JS</a></div></div><article class="prose md:prose-lg lg:prose-xl mx-auto"><p>Next.js Server Actions provide a groundbreaking method for integrating server-side operations directly into React applications, enabling optimized workflows for server logic and enhancing Next.js server-side integration. While they simplify workflows for mutations and server logic, their use for data fetching can present significant performance challenges. This guide explores these challenges, provides benchmark comparisons, and offers actionable solutions to optimize performance.</p>
<h2>Understanding Next.js Server Actions</h2>
<p>Next.js Server Actions have revolutionized server-side operations in React applications. Designed primarily for form handling and data mutations, they are increasingly used for data fetchingâ€”but not without challenges.</p>
<h3>What Are Server Actions?</h3>
<p>Server Actions in Next.js 14+ enable direct server-side operations from components. Their primary use cases include:</p>
<ul>
<li>Form submissions</li>
<li>Data mutations</li>
<li>Server-side state management</li>
<li>Database operations</li>
</ul>
<p>Server Actions promise simplicity by integrating server logic seamlessly with React components. However, using them for data fetching introduces critical performance challenges.</p>
<p>Learn more about Server Actions in the official <a href="https://nextjs.org/docs">Next.js documentation</a>.</p>
<h2>Performance Problems with Server Actions</h2>
<h3>HTTP Method Concerns</h3>
<p>Server Actions exclusively use POST requests, leading to several challenges when applied to data fetching:</p>
<ul>
<li>REST Principle Violation: GET requests are conventionally used for retrieving data. Using POST disrupts standard practices.</li>
<li>Caching Complexity: Caching mechanisms for GET requests, such as HTTP caching or CDN layers, are inherently easier to implement compared to POST.</li>
<li>Reduced API Intuition: POST-based data fetching can make APIs less predictable and harder to document for team collaboration.</li>
</ul>
<h3>Sequential Execution Problem</h3>
<p>A significant performance bottleneck arises when multiple Server Actions are invoked concurrently. Here's a common scenario:</p>

<div style="position: relative">
	<pre><code class="hljs language-typescript"><span class="hljs-string">&#x27;use server&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">{ id, delay }: { id: <span class="hljs-built_in">number</span>; delay: <span class="hljs-built_in">number</span> }</span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, delay));
  <span class="hljs-keyword">return</span> { id };
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="&apos;use server&apos;;

export async function fetchData({ id, delay }: { id: number; delay: number }) {
  await new Promise((resolve) => setTimeout(resolve, delay));
  return { id };
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<p>Executing this function for multiple requests:</p>

<div style="position: relative">
	<pre><code class="hljs language-typescript"><span class="hljs-comment">// These execute sequentially despite Promise.all</span>
<span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
  <span class="hljs-title function_">fetchData</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">1000</span> }),
  <span class="hljs-title function_">fetchData</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">1000</span> }),
  <span class="hljs-title function_">fetchData</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">1000</span> })
]);
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="// These execute sequentially despite Promise.all
const results = await Promise.all([
  fetchData({ id: 1, delay: 1000 }),
  fetchData({ id: 2, delay: 1000 }),
  fetchData({ id: 3, delay: 1000 })
]);
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<p>The expectation is concurrent execution, but the reality is sequential processing, dramatically increasing response times.</p>
<h3>Benchmark Results</h3>
<p>To quantify the performance of Server Actions, we conducted real-world testing with 10 concurrent requests, each with a 1000ms delay. The results:</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Execution Time</th>
<th>Performance Impact</th>
</tr>
</thead>
<tbody>
<tr>
<td>API Routes</td>
<td>1,195 ms</td>
<td>Best Performance</td>
</tr>
<tr>
<td>Concurrent Server Actions</td>
<td>2,274 ms</td>
<td>90% Improvement</td>
</tr>
<tr>
<td>Default Server Actions</td>
<td>11,444 ms</td>
<td>Baseline (Sequential)</td>
</tr>
</tbody>
</table>
<p>Key Insights:</p>
<ul>
<li>API Routes: Demonstrated near-ideal concurrent execution.</li>
<li>Concurrent Server Actions: Showed marked improvement over default Server Actions.</li>
<li>Default Server Actions: Suffered from severe sequential bottlenecks, rendering them impractical for high-performance needs.</li>
</ul>
<h2>Solutions and Best Practices</h2>
<h3>1. Use API Routes for Data Fetching</h3>
<p>API Routes remain the gold standard for data fetching in Next.js. Here's a straightforward implementation:</p>

<div style="position: relative">
	<pre><code class="hljs language-typescript"><span class="hljs-comment">// app/api/route.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;next/server&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">req: NextRequest</span>) {
  <span class="hljs-keyword">const</span> n = req.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;n&#x27;</span>);
  <span class="hljs-keyword">const</span> duration = <span class="hljs-title class_">Number</span>(req.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;duration&#x27;</span>));
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, duration));
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>({ n });
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="// app/api/route.ts
import { NextRequest } from &apos;next/server&apos;;

export async function GET(req: NextRequest) {
  const n = req.nextUrl.searchParams.get(&apos;n&apos;);
  const duration = Number(req.nextUrl.searchParams.get(&apos;duration&apos;));
  await new Promise((resolve) => setTimeout(resolve, duration));
  return Response.json({ n });
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<p>Advantages:</p>
<ul>
<li>Leverages HTTP GET, simplifying caching and alignment with REST principles.</li>
<li>Supports CDN optimizations out of the box.</li>
</ul>
<h3>2. Adopt the Concurrent Server Actions Pattern</h3>
<p>The concurrent pattern addresses the sequential execution issue inherent in default Server Actions. Unlike standard sequential processing, this approach utilizes concurrency to execute multiple actions simultaneously, significantly reducing overall execution time.</p>
<h4>How It Differs from Standard Approaches</h4>
<p>Default Server Actions process tasks one after the other, even when wrapped in promises, due to the server's handling of individual requests. This leads to significant delays in scenarios requiring multiple actions. By contrast, the concurrent pattern ensures that all operations begin immediately, leveraging JavaScript's asynchronous capabilities to minimize delays.</p>
<p>This distinction is critical for developers aiming to optimize server actions in Next.js and ensure efficient handling of complex workflows. Implementing the concurrent pattern can dramatically enhance performance, particularly for applications requiring high-volume data interactions. A custom utility can enable concurrent execution of Server Actions.</p>
<p>Utility Implementation:</p>

<div style="position: relative">
	<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> createConcurrentAction&lt;T, U <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]&gt;(
  <span class="hljs-attr">action</span>: <span class="hljs-function">(<span class="hljs-params">...args: U</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;T&gt;
) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (...<span class="hljs-attr">args</span>: U) =&gt; [<span class="hljs-title function_">action</span>(...args)] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> runConcurrentAction&lt;T&gt;(
  <span class="hljs-attr">result</span>: <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Promise</span>&lt;T&gt;]&gt;
) {
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> result)[<span class="hljs-number">0</span>];
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nonBlockingFetch = <span class="hljs-title function_">createConcurrentAction</span>(fetchData);
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="export function createConcurrentAction<T, U extends unknown[]>(
  action: (...args: U) => Promise<T>
) {
  return async (...args: U) => [action(...args)] as const;
}

export async function runConcurrentAction<T>(
  result: Promise<readonly [Promise<T>]>
) {
  return (await result)[0];
}

export const nonBlockingFetch = createConcurrentAction(fetchData);
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<p>Client-Side Usage:</p>

<div style="position: relative">
	<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
  <span class="hljs-title function_">runConcurrentAction</span>(<span class="hljs-title function_">nonBlockingFetch</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">1000</span> })),
  <span class="hljs-title function_">runConcurrentAction</span>(<span class="hljs-title function_">nonBlockingFetch</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">1000</span> })),
  <span class="hljs-title function_">runConcurrentAction</span>(<span class="hljs-title function_">nonBlockingFetch</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">delay</span>: <span class="hljs-number">1000</span> }))
]);
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="const results = await Promise.all([
  runConcurrentAction(nonBlockingFetch({ id: 1, delay: 1000 })),
  runConcurrentAction(nonBlockingFetch({ id: 2, delay: 1000 })),
  runConcurrentAction(nonBlockingFetch({ id: 3, delay: 1000 }))
]);
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<p>Advantages:</p>
<ul>
<li>Minimizes execution time for concurrent operations.</li>
<li>Maintains compatibility with Server Actions.</li>
</ul>
<h3>Implementation Guide</h3>
<h4>Step 1: Define the Base Action</h4>

<div style="position: relative">
	<pre><code class="hljs language-typescript"><span class="hljs-string">&#x27;use server&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processTask</span>(<span class="hljs-params">{ n, duration }: { n: <span class="hljs-built_in">number</span>; duration: <span class="hljs-built_in">number</span> }</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Running action <span class="hljs-subst">${n}</span>...`</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, duration));
  <span class="hljs-keyword">return</span> { n };
}
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="&apos;use server&apos;;

export async function processTask({ n, duration }: { n: number; duration: number }) {
  console.log(`Running action ${n}...`);
  await new Promise((resolve) => setTimeout(resolve, duration));
  return { n };
}
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h4>Step 2: Create a Concurrent Version</h4>

<div style="position: relative">
	<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nonBlockingProcessTask = <span class="hljs-title function_">createConcurrentAction</span>(processTask);
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="export const nonBlockingProcessTask = createConcurrentAction(processTask);
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h4>Step 3: Execute Client-Side</h4>

<div style="position: relative">
	<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
  <span class="hljs-title function_">runConcurrentAction</span>(<span class="hljs-title function_">nonBlockingProcessTask</span>({ <span class="hljs-attr">n</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span> })),
  <span class="hljs-title function_">runConcurrentAction</span>(<span class="hljs-title function_">nonBlockingProcessTask</span>({ <span class="hljs-attr">n</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span> })),
  <span class="hljs-title function_">runConcurrentAction</span>(<span class="hljs-title function_">nonBlockingProcessTask</span>({ <span class="hljs-attr">n</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span> }))
]);
</code></pre>

	<button class="markdown-it-code-copy btn btn-ghost btn-circle btn-sm" data-clipboard-text="const results = await Promise.all([
  runConcurrentAction(nonBlockingProcessTask({ n: 1, duration: 1000 })),
  runConcurrentAction(nonBlockingProcessTask({ n: 2, duration: 1000 })),
  runConcurrentAction(nonBlockingProcessTask({ n: 3, duration: 1000 }))
]);
" style="position: absolute; top: 7.5px; right: 6px; cursor: pointer; outline: none;" title="Copy">
		<span style="font-size: 21px; opacity: 0.4;" class="fa fa-solid fa-clone text-neutral-content"></span>
	</button>
</div>
<h2>Conclusion and Recommendations</h2>
<p>Server Actions present a transformative opportunity for integrating server-side logic into React applications, offering efficiency and flexibility. However, leveraging them for data fetching requires a nuanced understanding of their benefits and limitations to maximize their potential in Next.js workflows.</p>
<h3>Best Practices</h3>
<p>For Data Fetching:</p>
<ul>
<li>Prefer API Routes for optimal performance and simplicity.</li>
<li>Use tools like React Query or SWR for client-side caching and revalidation.</li>
</ul>
<p>When Using Server Actions:</p>
<ul>
<li>Apply the concurrent execution pattern to avoid sequential bottlenecks.</li>
<li>Recognize the inherent overhead (~1,000ms) compared to API Routes.</li>
<li>Consider batch operations for related requests.</li>
</ul>
<p>For Sequential Operations:</p>
<ul>
<li>Default Server Actions may suffice.</li>
<li>Explore batch endpoints for efficiency.</li>
</ul>
<h3>Key Takeaways</h3>
<ul>
<li>Mutations: Server Actions excel for data mutations but need optimization for fetching.</li>
<li>Concurrency: The concurrent pattern delivers a 90% performance improvement.</li>
<li>API Routes: Remain the go-to for data fetching due to their flexibility and speed.</li>
</ul>
<p>Explore related resources:</p>
<p><a href="https://github.com/Pasquale-Favella/next-concurrent-server-actions">Github repository example</a></p>
<p><a href="https://tanstack.com/query/latest">React Query Documentation</a></p>
<p><a href="https://swr.vercel.app/">SWR Documentation</a></p>
<p><a href="https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations">Server Actions Guide</a></p>
<p><a href="https://nextjs.org/docs/app/building-your-application/data-fetching/fetching">Next.js Data Fetching Practices</a></p>
<p>Happy coding!</p>
</article><div class="my-8"></div></main><footer class="text-gray-600"><div class="max-w-6xl px-5 py-4 mx-auto flex items-center sm:flex-row flex-col"><a class="text-primary hover:underline underline-offset-2" aria-label="Email to paskfdev@gmail.com" title="Email to paskfdev@gmail.com" href="mailto:paskfdev@gmail.com">Pasquale Favella</a><p class="text-sm text-gray-500 sm:ml-4 sm:pl-4 sm:border-l-2 sm:border-gray-200 sm:py-2 sm:mt-0 mt-4">Â©<!-- -->2025<!-- --> â€¢ made with ðŸ’š</p><span class="inline-flex sm:ml-auto sm:mt-0 mt-4 justify-center items-center sm:justify-start gap-4"><a class="transition-all duration-300 hover:text-primary" href="https://github.com/Pasquale-Favella"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a class="transition-all duration-300 hover:text-primary" href="https://it.linkedin.com/in/pasquale-favella-1a3682187"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg></a></span></div><div class="fixed bottom-4 right-1 sm:bottom-10 sm:right-6 z-50 tooltip tooltip-left before:text-xs before:content-[attr(data-tip)]" data-tip="ask a question" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:Rbl6:" data-state="closed"><button class="btn btn-ghost btn-circle "><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="40" width="40" xmlns="http://www.w3.org/2000/svg"><path d="M16 8c0 3.866-3.582 7-8 7a9.06 9.06 0 0 1-2.347-.306c-.584.296-1.925.864-4.181 1.234-.2.032-.352-.176-.273-.362.354-.836.674-1.95.77-2.966C.744 11.37 0 9.76 0 8c0-3.866 3.582-7 8-7s8 3.134 8 7zM7.194 6.766a1.688 1.688 0 0 0-.227-.272 1.467 1.467 0 0 0-.469-.324l-.008-.004A1.785 1.785 0 0 0 5.734 6C4.776 6 4 6.746 4 7.667c0 .92.776 1.666 1.734 1.666.343 0 .662-.095.931-.26-.137.389-.39.804-.81 1.22a.405.405 0 0 0 .011.59c.173.16.447.155.614-.01 1.334-1.329 1.37-2.758.941-3.706a2.461 2.461 0 0 0-.227-.4zM11 9.073c-.136.389-.39.804-.81 1.22a.405.405 0 0 0 .012.59c.172.16.446.155.613-.01 1.334-1.329 1.37-2.758.942-3.706a2.466 2.466 0 0 0-.228-.4 1.686 1.686 0 0 0-.227-.273 1.466 1.466 0 0 0-.469-.324l-.008-.004A1.785 1.785 0 0 0 10.07 6c-.957 0-1.734.746-1.734 1.667 0 .92.777 1.666 1.734 1.666.343 0 .662-.095.931-.26z"></path></svg></button></div></footer></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"content":"Next.js Server Actions provide a groundbreaking method for integrating server-side operations directly into React applications, enabling optimized workflows for server logic and enhancing Next.js server-side integration. While they simplify workflows for mutations and server logic, their use for data fetching can present significant performance challenges. This guide explores these challenges, provides benchmark comparisons, and offers actionable solutions to optimize performance.\n\n## Understanding Next.js Server Actions\n\nNext.js Server Actions have revolutionized server-side operations in React applications. Designed primarily for form handling and data mutations, they are increasingly used for data fetchingâ€”but not without challenges.\n\n### What Are Server Actions?\n\nServer Actions in Next.js 14+ enable direct server-side operations from components. Their primary use cases include:\n\n* Form submissions\n* Data mutations\n* Server-side state management\n* Database operations\n\nServer Actions promise simplicity by integrating server logic seamlessly with React components. However, using them for data fetching introduces critical performance challenges.\n\nLearn more about Server Actions in the official [Next.js documentation](https://nextjs.org/docs).\n\n## Performance Problems with Server Actions\n\n### HTTP Method Concerns\n\nServer Actions exclusively use POST requests, leading to several challenges when applied to data fetching:\n\n* REST Principle Violation: GET requests are conventionally used for retrieving data. Using POST disrupts standard practices.\n* Caching Complexity: Caching mechanisms for GET requests, such as HTTP caching or CDN layers, are inherently easier to implement compared to POST.\n* Reduced API Intuition: POST-based data fetching can make APIs less predictable and harder to document for team collaboration.\n\n### Sequential Execution Problem\n\nA significant performance bottleneck arises when multiple Server Actions are invoked concurrently. Here's a common scenario:\n\n```typescript\n'use server';\n\nexport async function fetchData({ id, delay }: { id: number; delay: number }) {\n  await new Promise((resolve) =\u003e setTimeout(resolve, delay));\n  return { id };\n}\n```\n\nExecuting this function for multiple requests:\n\n```typescript\n// These execute sequentially despite Promise.all\nconst results = await Promise.all([\n  fetchData({ id: 1, delay: 1000 }),\n  fetchData({ id: 2, delay: 1000 }),\n  fetchData({ id: 3, delay: 1000 })\n]);\n```\n\nThe expectation is concurrent execution, but the reality is sequential processing, dramatically increasing response times.\n\n### Benchmark Results\n\nTo quantify the performance of Server Actions, we conducted real-world testing with 10 concurrent requests, each with a 1000ms delay. The results:\n\n| Approach | Execution Time | Performance Impact |\n|----------|---------------|-------------------|\n| API Routes | 1,195 ms | Best Performance |\n| Concurrent Server Actions | 2,274 ms | 90% Improvement |\n| Default Server Actions | 11,444 ms | Baseline (Sequential) |\n\nKey Insights:\n* API Routes: Demonstrated near-ideal concurrent execution.\n* Concurrent Server Actions: Showed marked improvement over default Server Actions.\n* Default Server Actions: Suffered from severe sequential bottlenecks, rendering them impractical for high-performance needs.\n\n## Solutions and Best Practices\n\n### 1. Use API Routes for Data Fetching\n\nAPI Routes remain the gold standard for data fetching in Next.js. Here's a straightforward implementation:\n\n```typescript\n// app/api/route.ts\nimport { NextRequest } from 'next/server';\n\nexport async function GET(req: NextRequest) {\n  const n = req.nextUrl.searchParams.get('n');\n  const duration = Number(req.nextUrl.searchParams.get('duration'));\n  await new Promise((resolve) =\u003e setTimeout(resolve, duration));\n  return Response.json({ n });\n}\n```\n\nAdvantages:\n* Leverages HTTP GET, simplifying caching and alignment with REST principles.\n* Supports CDN optimizations out of the box.\n\n### 2. Adopt the Concurrent Server Actions Pattern\n\nThe concurrent pattern addresses the sequential execution issue inherent in default Server Actions. Unlike standard sequential processing, this approach utilizes concurrency to execute multiple actions simultaneously, significantly reducing overall execution time.\n\n#### How It Differs from Standard Approaches\n\nDefault Server Actions process tasks one after the other, even when wrapped in promises, due to the server's handling of individual requests. This leads to significant delays in scenarios requiring multiple actions. By contrast, the concurrent pattern ensures that all operations begin immediately, leveraging JavaScript's asynchronous capabilities to minimize delays.\n\nThis distinction is critical for developers aiming to optimize server actions in Next.js and ensure efficient handling of complex workflows. Implementing the concurrent pattern can dramatically enhance performance, particularly for applications requiring high-volume data interactions. A custom utility can enable concurrent execution of Server Actions.\n\nUtility Implementation:\n\n```typescript\nexport function createConcurrentAction\u003cT, U extends unknown[]\u003e(\n  action: (...args: U) =\u003e Promise\u003cT\u003e\n) {\n  return async (...args: U) =\u003e [action(...args)] as const;\n}\n\nexport async function runConcurrentAction\u003cT\u003e(\n  result: Promise\u003creadonly [Promise\u003cT\u003e]\u003e\n) {\n  return (await result)[0];\n}\n\nexport const nonBlockingFetch = createConcurrentAction(fetchData);\n```\n\nClient-Side Usage:\n\n```typescript\nconst results = await Promise.all([\n  runConcurrentAction(nonBlockingFetch({ id: 1, delay: 1000 })),\n  runConcurrentAction(nonBlockingFetch({ id: 2, delay: 1000 })),\n  runConcurrentAction(nonBlockingFetch({ id: 3, delay: 1000 }))\n]);\n```\n\nAdvantages:\n* Minimizes execution time for concurrent operations.\n* Maintains compatibility with Server Actions.\n\n### Implementation Guide\n\n#### Step 1: Define the Base Action\n\n```typescript\n'use server';\n\nexport async function processTask({ n, duration }: { n: number; duration: number }) {\n  console.log(`Running action ${n}...`);\n  await new Promise((resolve) =\u003e setTimeout(resolve, duration));\n  return { n };\n}\n```\n\n#### Step 2: Create a Concurrent Version\n\n```typescript\nexport const nonBlockingProcessTask = createConcurrentAction(processTask);\n```\n\n#### Step 3: Execute Client-Side\n\n```typescript\nconst results = await Promise.all([\n  runConcurrentAction(nonBlockingProcessTask({ n: 1, duration: 1000 })),\n  runConcurrentAction(nonBlockingProcessTask({ n: 2, duration: 1000 })),\n  runConcurrentAction(nonBlockingProcessTask({ n: 3, duration: 1000 }))\n]);\n```\n\n## Conclusion and Recommendations\n\nServer Actions present a transformative opportunity for integrating server-side logic into React applications, offering efficiency and flexibility. However, leveraging them for data fetching requires a nuanced understanding of their benefits and limitations to maximize their potential in Next.js workflows.\n\n### Best Practices\n\nFor Data Fetching:\n* Prefer API Routes for optimal performance and simplicity.\n* Use tools like React Query or SWR for client-side caching and revalidation.\n\nWhen Using Server Actions:\n* Apply the concurrent execution pattern to avoid sequential bottlenecks.\n* Recognize the inherent overhead (~1,000ms) compared to API Routes.\n* Consider batch operations for related requests.\n\nFor Sequential Operations:\n* Default Server Actions may suffice.\n* Explore batch endpoints for efficiency.\n\n### Key Takeaways\n\n* Mutations: Server Actions excel for data mutations but need optimization for fetching.\n* Concurrency: The concurrent pattern delivers a 90% performance improvement.\n* API Routes: Remain the go-to for data fetching due to their flexibility and speed.\n\nExplore related resources:\n\n[Github repository example](https://github.com/Pasquale-Favella/next-concurrent-server-actions)\n\n[React Query Documentation](https://tanstack.com/query/latest)\n\n[SWR Documentation](https://swr.vercel.app/)\n\n[Server Actions Guide](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)\n\n[Next.js Data Fetching Practices](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching)\n\nHappy coding!","slug":"27","title":"Next.js Server Actions for Data Fetching: Performance Issues and Solutions","meta_description":"Next","tags":["React","Next JS"]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"27"},"buildId":"RHGHCub-nt6FBtRy5YMos","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>